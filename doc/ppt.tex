%\documentclass[handout]{beamer} % Sin animaciones
% https://tex.stackexchange.com/questions/74805/latex-error-option-clash-for-package-xcolor
\documentclass[xcolor={dvipsnames},spanish]{beamer}
%\usetheme{Warsaw}
\usetheme{Madrid}
\setbeamertemplate{navigation symbols}{} % remove navigation symbols
%\setbeamercolor{alerted text}{fg=orange}

\usepackage{thesis}
\usepackage{sections/nd_rules}
\setbeamertemplate{footline}[frame number]

\usepackage{cancel} % https://tex.stackexchange.com/questions/23711/strikethrough-text
% https://tex.stackexchange.com/questions/362077/line-jump-using-the-xcancel-macro-in-beamer/362236#362236
\newcommand<>{\xxcancel}[1]{\alt#2{\xcancel{#1}}{\vphantom{\xcancel{#1}}#1}}%uncover the xcancel command


% https://tex.stackexchange.com/questions/464916/listing-inside-a-frame-using-beamer
\lstset{language=ppa, xleftmargin=0.5cm}

\renewcommand{\lstlistingname}{Programa}

\newcommand{\fForm}{F}
\newcommand{\cForm}{C}

\usepackage{fitch}

% https://tex.stackexchange.com/questions/178800/creating-sections-each-with-title-pages-in-beamers-slides
\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\AtBeginSubsection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsubsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newenvironment{command}
    {
        \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{block body}
    }
    {\end{beamercolorbox}}


% Justificaciones
\newcommand{\just}[1]{\textcolor{violet}{(#1)}}

% Tiempo total para dar la presentación: 60 minutos, 15 para preguntas
% cada diapo 1-2m. 50 diapos.

% Notas

\title{PPA}
\subtitle{Un asistente de demostración para
lógica de primer orden con extracción de
testigos usando la traducción de Friedman}
\author{Manuel Panichelli}
\institute{Deparatamento de Computación, FCEyN, UBA}
\date{Diciembre 2024}

\begin{document}


\frame{\titlepage}

\section{Introducción}

\begin{frame}{Repaso de lógica}
    \begin{itemize}
        \item \textbf{Teorema}: Afirmación que puede ser \textit{demostrada}.
        \item \textbf{Demostración} de un teorema:
        \begin{itemize}
            \item \textit{Argumento} que establece que el teorema es cierto
            \item Usa \textit{reglas de inferencia} a partir de \textit{axiomas} y otros teoremas probados anteriormente. 
        \end{itemize}
        \item \textbf{Axiomas}: Afirmaciones que son siempre válidas (sin demostración).
    \end{itemize}
\end{frame}

\begin{frame}{Ejemplo de teorema}
    \begin{example}[Teorema de Pitágoras]
        \begin{columns}
            \begin{column}{0.5\textwidth}
                \[
                a^2 + b^2 = c^2.
                \]
            \end{column}
            \begin{column}{0.5\textwidth}
                \begin{figure}[H]
                    \includegraphics[scale=0.4]{img/ppt/pitagoras.png}
                \end{figure}
            \end{column}
        \end{columns}
        \begin{itemize}
            \item \textbf{Sistema}: Geometría euclidiana
            \item Un axioma: se puede dibujar una línea recta entre dos puntos
        \end{itemize}
    \end{example}
\end{frame}

% TODO: Considerar explicar que es un teorema y qué es la verificación
\begin{frame}{Asistentes de demostración}
    \begin{itemize}
        \item Los \textbf{asistentes de demostración} son herramientas que
        facilitan la escritura y el chequeo de demostraciones por
        computadora.
        \item Usos usuales:
        \begin{itemize}
            \item Formalización de teoremas matemáticos.
            \item Verificación de programas.
        \end{itemize}
        \pause
        \item Ventajas:\footnote{\href{https://youtu.be/AayZuuDDKP0?si=eGETzgh9PQ_8JecR}{Terrence Tao - Machine Assisted Proof}}
        \begin{itemize}
            \item Facilitan la colaboración a gran escala (mediante la confianza en el asistente).\pause
            \item Habilitan generación automática de demostraciones con IA. Por ej. un \textit{LLM} (como \textit{ChatGPT}) suele devolver alucinaciones, que pueden ser filtradas automáticamente con un asistente.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Asistentes de demostración}
    \begin{figure}
        \includegraphics[scale=0.25]{img/ppt/proof-assistants.png}
    \end{figure}
    \pause
    \textbf{Extracción de testigos}: De una demo de
    $\exists \var . \pred(\var)$, encontrar $\term$ tq $\pred(\term)$.

    Lógica constructiva = sencillo, no constructiva = complicado.
\end{frame}

\begin{frame}{PPA}
    \begin{figure}
        \includegraphics[scale=0.25]{img/ppt/ppa-tool-parts.png}
    \end{figure}
    Diseñamos e implementamos en Haskell la herramienta \ppaTool{} (\textit{Pani's Proof Assistant}): un asistente de demostración para LPO \textbf{clásica}. Dos partes:
    \begin{itemize}
        \item El lenguaje \textbf{PPA} para escribir demostraciones.
        \item \textbf{Extracción de testigos} \alert{(Aporte principal)}.
    \end{itemize}
\end{frame}

\begin{frame}{Representación de demostraciones}
    ¿Cómo representamos las demostraciones? Ejemplo:
    
    \begin{itemize}
        \item Tenemos dos premisas
        \begin{enumerate}
            \item Los alumnos que faltan a los exámenes, los reprueban.
            \item Si se reprueba un final, se recursa la materia.
        \end{enumerate}
        \item A partir de ellas, podríamos demostrar que si un alumno falta a un final, entonces recursa la materia.
    \end{itemize}

    \pause

    \begin{theorem}
        Si ((falta entonces reprueba) y (reprueba entonces recursa)) y falta, entonces recursa
    \end{theorem}
    \begin{proof}
        \begin{itemize}
    \item Asumo que falta. Quiero ver que recursa.
    \item Sabemos que si falta, entonces reprueba. Por lo tanto reprobó.
    \item Sabemos que si reprueba, entonces recursa. Por lo tanto recursó.
\end{itemize}
    \end{proof}
\end{frame}

\begin{frame}{Sistemas deductivos}
    \begin{itemize}
        \item \textbf{Problema}: Poco precisa. No se puede representar rigurosamente.
        \item Necesitamos \textbf{sistemas deductivos}: sistemas lógicos formales usados para escribir demostraciones
        \item Usamos \textbf{deducción natural}
        \begin{itemize}
            \item \textbf{Lenguaje formal}: lógica de primer orden.
            \item \textbf{Reglas de inferencia}: Por ejemplo,
            \begin{itemize}
            \item \textit{modus ponens}: si
            es cierto $\form \fImp \formTwo$ y $\form$, se puede concluir $\formTwo$
            \item \textit{modus tollens}: si es cierto $\form \fImp \formTwo$ y $\fNot \formTwo$, se puede concluir $\fNot\form$
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Lógica de primer orden}

\begin{definition}[Términos]
    Los términos están dados por la gramática:
    \begin{align*}
        \term ::= &\ \var                               &\text{(variables)} \\
                  & \mid \fun(\term_1, \dots, \term_n) &\text{(funciones)}
    \end{align*}
\end{definition}
\begin{definition}[Fórmulas]
    Las fórmulas están dadas por la gramática:
    \begin{align*}
        \form, \formTwo ::=
         & \ \pred(\term_1, \dots, \term_n) & (\text{predicados})                \\
         & \mid \fFalse                     
           \mid \fTrue                      & \text{(falso o \textit{bottom} y verdadero o \textit{top})} \\
         & \mid \form \fAnd \formTwo                        
           \mid \form \fOr \formTwo           & \text{(conjunción y disyunción)}     \\
         & \mid \form \fImp \formTwo                       
           \mid \fNot \form                 & \text{(implicación y negación)}                  \\
         & \mid \forall \var . \form        
           \mid \exists \var . \form        & \text{(cuantificador universal y existencial)}
    \end{align*}
\end{definition}

\end{frame}

% \begin{frame}{Lógica de primer orden}
% Los predicados son \textbf{fórmulas atómicas}. Los de aridad 0 además son llamados \textit{variables proposicionales}.

% \begin{notation*}
%     Usamos
%     \begin{itemize}
%         \item $\var, \varTwo, \varThree, \dots$ como \textbf{variables}.
%         \item $\fun, \funTwo, \funThree, \dots$ como \textbf{símbolos de función}.
%         \item $\pred, \predTwo, \predThree, \dots$ como \textbf{símbolos de predicado}.
%         \item $\term, \termTwo, \dots$ para referirnos a \textbf{términos}.
%         \item $\formLit, \formLitTwo, \formLitThree, \dots$, $\form, \formTwo, \formThree, \dots$ y $\anyForm, \anyFormTwo, \dots$ para referirnos a \textbf{fórmulas}.
%     \end{itemize}
% \end{notation*}
% \end{frame}

\section{Deducción natural}

\begin{frame}{Ejemplo}
    \begin{example}[Demostración en DN]
        Notamos:
        \begin{itemize}
            \item $\reprueba \equiv \predReprueba(juan, \funFinal(logica))$
            \item $\recursa \equiv \predRecursa(juan, logica)$
            \item $\falta \equiv \predFalta(juan, \funFinal(logica))$
        \end{itemize}
        Queremos probar
        \[
            \Big(
                (\falta \fImp \reprueba) \wedge (\reprueba \fImp \recursa)
            \Big)
            \fImp
            (\falta \fImp \recursa)
        \]
    \end{example}
\end{frame}

\begin{frame}{Ejemplo}
    \begin{example}[Demostración en DN]
        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judG (\falta \fImp \reprueba) \wedge (\reprueba \fImp \recursa)$}
            \RL{\ruleAndEOne}
            \UnaryInfC{$\ctx \judG \reprueba \fImp \recursa$}
        
            \AxiomC{$\someProof$}
            \noLine
        \UnaryInfC{$\ctx \judG \reprueba$}
        \RL{\ruleImpE}
        \BinaryInfC{\(
            \ctx =
            (\falta \fImp \reprueba) \wedge (\reprueba \fImp \recursa),\
            \falta
            \judG
            \recursa
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            (\falta \fImp \reprueba) \wedge (\reprueba \fImp \recursa)
            \judG
            \falta \fImp \recursa 
            \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \judG
            \Big(
                (\falta \fImp \reprueba) \wedge (\reprueba \fImp \recursa)
                \Big)
                \fImp
                (\falta \fImp \recursa)
                \)}
        \end{prooftree}
        
        donde
        \pause
        
        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judG (\falta \fImp \reprueba) \wedge (\reprueba \fImp \recursa)$}
            \RL{\ruleAndETwo}
            \UnaryInfC{$\ctx \judG \falta \fImp \reprueba$}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judG \falta$}
            \RL{\ruleImpE}
            \LL{$\someProof=$}
            \BinaryInfC{$\ctx \judG \reprueba$}
        \end{prooftree}
    \end{example}
\end{frame}

\begin{frame}{Deducción natural}
    \begin{definition}[Contexto de demostración]
        $\ctx$ es un \textbf{contexto de demostración}, conjunto de
        fórmulas que se asumen válidas.

        \textbf{Notación}: $\ctx, \anyForm = \ctx \cup \{\anyForm\}$
    \end{definition}
    \pause
    \begin{definition}[Relación de derivabilidad]
        \begin{itemize}
            \item $\judG$ es la \textbf{relación de derivabilidad} definida a
            partir de las \textit{reglas de inferencia}.
            \item Permite escribir
            juicios $\ctx \judG \anyForm$. Intuición: \textit{``$\anyForm$ es
            una consecuencia de las suposiciones de $\ctx$''}
            \item Es cierto si en una cantidad finita de
            pasos podemos concluir $\anyForm$ a partir de las fórmulas de
            $\ctx$, los axiomas y las reglas de inferencia.
        \end{itemize}
    \end{definition}
\end{frame}

\begin{frame}{Reglas de inferencia}
    \begin{definition}[Reglas de inferencia]
        \begin{columns}
            \column{0.5\textwidth}
            \proofTreeAx
            \proofTreeImpI
            \proofTreeImpE
            \column{0.5\textwidth}
            \proofTreeAndI
            \proofTreeAndEOne
            \proofTreeAndETwo
        \end{columns}
        
    \end{definition}
    Dos tipos para cada conectivo y cuantificador, dada una fórmula formada con un conectivo:
    \begin{itemize}
        \item \textbf{Introducción}: ¿Cómo la demuestro?
        \item \textbf{Eliminación}: ¿Cómo la uso para demostrar otra?
    \end{itemize}
\end{frame}



\begin{frame}{Reglas de inferencia}
    Otras reglas de inferencia
    \begin{itemize}
        \item \ruleFalseE, \ruleTrueI
        \item \ruleNotI, \ruleNotE
        \item \ruleOrIOne, \ruleOrITwo, \ruleOrE
        \item \ruleForallI, \ruleForallE
        \item \ruleExistsI, \ruleExistsE
        \item \ruleLEM
    \end{itemize}
    \pause
    \begin{block}{Alfa equivalencia}
        \begin{itemize}
            \item Podemos usar $\exists \var . \pred(\var)$ y $\exists \varTwo . \pred(\varTwo)$ intercambiablemente.
            \item Son $\alpha$-equivalentes (renombrando variables ligadas de forma apropiada, son iguales).
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Reglas admisibles}
    \begin{itemize}
        \item Mencionamos \textit{modus tollens} pero no aparece en las reglas de inferencia.
        \item Queremos un sistema lógico \textbf{minimal}: no agregamos las reglas \textbf{admisibles}, derivables a partir de las existentes.
        \item Se implementan como funciones o \textit{macros}.
    \end{itemize} 

    \begin{lemma}[Modus tollens]
        
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(\ctx \judG (\form \fImp \formTwo) \fAnd \fNot \formTwo\)}
        \RL{\ruleAndETwo}
        \UnaryInfC{\(
            \ctx \judG \fNot \formTwo
        \)}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(\ctx \judG (\form \fImp \formTwo) \fAnd \fNot \formTwo\)}
        \RL{\ruleAndEOne}
        \UnaryInfC{$\ctx \judG \form \fImp \formTwo$}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\ctx \judG \form$}
        \RL{\ruleImpE}
        \BinaryInfC{\(
            \ctx \judG \formTwo
        \)}
        \RL{\ruleNotE{}}
        \BinaryInfC{\(
            \ctx = (\form \fImp \formTwo) \fAnd \fNot \formTwo, \form
            \judG
            \fFalse
        \)}
        \RL{\ruleNotI{}}
        \UnaryInfC{\(
            (\form \fImp \formTwo) \fAnd \fNot \formTwo
            \judG
            \fNot \form
        \)}
        \RL{\ruleImpI{}}
        \UnaryInfC{\(\judG
            (\form \fImp \formTwo \fAnd \fNot \formTwo)
            \fImp \fNot\form
        \)}
    \end{prooftree}
    \end{lemma}
\end{frame}

\begin{frame}{Sustitución}
    \begin{definition}[Sustitución]
        Notamos como $\form \subst{\var}{\term}$ a la sustitución de todas las
        ocurrencias libres de la variable $\var$ por el término $\term$ en la
        fórmula $\form$.
    \end{definition}
    \begin{exampleblock}{Eliminación de universal}
        \proofTreeForallE
    \end{exampleblock}
    \begin{block}{Capturas}
        Evitamos automáticamente la \textbf{captura de variables}
        \begin{align*}
        (\forall \varTwo . \pred(\var))\subst{\var}{\varTwo} &\not =
        \forall \varTwo . \pred(\alert{\varTwo}) & & \text{(capturada)}\\
        (\forall \varTwo . \pred(\var))\subst{\var}{\varTwo} &=
        \forall \alert{\varThree} . \pred(\varTwo) & & \text{(renombrada)}
        \end{align*}
    \end{block}
\end{frame}

%\begin{frame}{Alfa equivalencia}
    % \begin{itemize}
    %     \item Algoritmo naíf: cuadrático en la estructura de la fórmula,
    %     renombrando recursivamente.
    %     \item Algoritmo cuasilineal: manteniendo dos sustituciones, una por
    %     fórmula.
    % \end{itemize}
    % \begin{example}
    %     \begin{align*}
    %         (\exists \var . \fun(\var)) &\alphaEq (\exists \varTwo . \fun(\varTwo))
    %         &&\{\}, \{\}
    %         \\
    %         &\iff \fun(\var) \alphaEq \fun(\varTwo)
    %             &&\{\var \mapsto \varThree\}, \{\varTwo \mapsto \varThree\}\\
    %         &\iff \var \alphaEq \varTwo
    %             &&\{\var \mapsto \varThree\}, \{\varTwo \mapsto \varThree\}\\
    %         &\iff \varThree = \varThree.
    %     \end{align*}        
    % \end{example}
%\end{frame}

\section{PPA}

\begin{frame}{Mathematical Vernacular}

    \begin{center}
        \textit{Mathematical
        Vernacular}\footnote{De Freek Wiedijk} = Mizar + Isar (Isabelle)    
    \end{center}
    

    Forma \textit{natural} de representar demostraciones matemáticas. Ideas:

    \begin{itemize}[<+->]
        \item \textbf{Deducción natural en estilo de \textit{Fitch}}. Notación
        equivalente, demostraciones como listas de fórmulas en lugar de árboles.
        \item \textbf{Reglas de inferencia \textit{declarativas}}: Afirmar
         \[\form_1, \dots, \form_n \judG \form\] sin
        tener que demostrarlo a mano (automático).
        \item \textbf{Sintaxis similar a un lenguaje de programación} en lugar al lenguaje natural.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{PPA}
    \textit{Lenguaje} PPA, inspirado en el
    \textit{Mathematical Vernacular}. Demostraciones son listas de \textbf{comandos} que reducen sucesivamente la \textit{tesis} (fórmula a demostrar) hasta agotarla.
    \onslide<1->{\lstinputlisting[title=Ejemplo demostración,lastline=4]{listings/ppt/alumnos-corto.ppa}}\vspace*{-\baselineskip}

    \onslide<2->{\lstinputlisting[firstnumber=last,firstline=5,lastline=8]{listings/ppt/alumnos-corto.ppa}}\vspace*{-\baselineskip}
    \onslide<3->{\lstinputlisting[firstnumber=last,firstline=9,lastline=10]{listings/ppt/alumnos-corto.ppa}}\vspace*{-\baselineskip}
    \onslide<4->{\lstinputlisting[firstnumber=last,firstline=11,lastline=11]{listings/ppt/alumnos-corto.ppa}}\vspace*{-\baselineskip}
    \onslide<5->{\lstinputlisting[firstnumber=last,firstline=12,lastline=12]{listings/ppt/alumnos-corto.ppa}}\vspace*{-\baselineskip}
    \onslide<6->{\lstinputlisting[firstnumber=last,firstline=13]{listings/ppt/alumnos-corto.ppa}}\vspace*{-\baselineskip}
\end{frame}


% \begin{frame}[fragile]{Identificadores}
%     \begin{itemize}
%         \item \textbf{Variables} (\lstinline{<var>})
%         \begin{center}
%             \verb/(\_|[A-Z])[a-zA-Z0-9\_\-]*(\')*/
%         \end{center}
%         \item \textbf{Identificadores} (\lstinline{<id>})
%         \begin{center}
%             \verb/[a-zA-Z0-9\_\-\?!#\$\%\*\+\<\>\=\?\@\^]+(\')*/
%         \end{center}
%         \item \textbf{Nombres} (\lstinline{<name>})
        
%         Pueden ser identificadores o strings arbitrarios encerrados por comillas dobles.
%         \begin{center}
%             \verb/<id> | \"[^\"]*\"/
%         \end{center}
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Programas}
%     Un \textbf{programa} de PPA consiste en una lista de \textbf{declaraciones},
%     que pueden ser
%     \begin{itemize}
%         \item \textbf{Axiomas}: fórmulas que se asumen válidas
%         \begin{lstlisting}[numbers=none]
% axiom <name> : <form>
%         \end{lstlisting}
%         \item \textbf{Teoremas}: fórmulas junto con sus demostraciones.
% \begin{lstlisting}[numbers=none]
% theorem <name> : <form>
% proof
%     <steps>
% end
% \end{lstlisting}
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Fórmulas y términos}
%     Términos:
%     \begin{itemize}
%         \item Variables: \lstinline{<var>}
%         \item Funciones: \lstinline{<id>(<term>, ..., <term>)}
%     \end{itemize}

%     Funciones:
%     \begin{itemize}
%         \item Predicados: \lstinline{<id>(<term>, ..., <term>)}
%         \item \lstinline{<form> & <form>}
%         \item \lstinline{<form> | <form>}
%         \item \lstinline{<form> -> <form>}
%         \item \lstinline{<form> <-> <form>}
%         \item \lstinline{~ <form>}
%         \item \lstinline{exists <var> . <form>}
%         \item \lstinline{forall <var> . <form>}
%         \item \lstinline{true}, \lstinline{false}
%         \item \lstinline{(<form>)}
%     \end{itemize}
% \end{frame}

% \begin{frame}{Demostraciones}
%     \begin{columns}
%         \begin{column}{0.5\textwidth}
%             \includegraphics[scale=0.25]{img/ppt/dem-reduccion.png}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             Lista de \textbf{comandos} que reducen sucesivamente la \textit{tesis} (fórmula a demostrar) hasta agotarla.
%         \end{column}
%     \end{columns}
% \end{frame}

\begin{frame}{by - El mecanismo principal de demostración}
    \begin{command}
        \lstinline{thus <form> by <h1>, ..., <hn>}
        \lstinline{have <name>: <form> by <h1>, ..., <hn>}
    \end{command}
    %\begin{center}
    %    \lstinline{<form> by <h1>, ..., <hn>}
    %\end{center}
    \begin{itemize}
        %\item Los nombres de las hipótesis son del tipo \lstinline{<name>} (o bien identificadores o \textit{strings} arbitrarios).
        \item Por debajo usa un \textit{solver} completo para lógica proposicional pero \textit{heurístico} para primer orden.
        \item Si puede, demuestra \textbf{automáticamente} que la fórmula es consecuencia lógica de la justificación.
        \item Toma las hipótesis del \textbf{contexto}:
        fórmulas asumidas (axiomas) o demostradas (teoremas y comandos que
        demuestran hipótesis auxiliares).
    \end{itemize}
\end{frame}


% \begin{frame}[fragile]{Thus y Have}
%     \begin{command}
%     \lstinline{thus <form> by <h1>, ..., <hn>}

%     \vspace{0.25cm}

%     Si \lstinline{<form>} es \textit{parte} de la tesis, y el \textit{solver} puede demostrar la implicación, lo demuestra automáticamente y lo descarga de la tesis.
%     \end{command}

%     \vspace{0.25cm}

%     \begin{command}
%         \lstinline{have <name>: <form> by <h1>, ..., <hn>}
    
%         \vspace{0.25cm}
    
%         Análogo a \lstinline{thus}, pero introduce una afirmación \textit{auxiliar}
%         sin reducir la tesis, agregándola al contexto.
%     \end{command}    
    % \vspace{-0.4cm}
    % \begin{columns}[t]
    %     \begin{column}{0.5\textwidth}
    %         \lstinputlisting[title=Eliminación de implicación]{listings/interfaz/by-imp.ppa}
    %     \end{column}
    %     \begin{column}{0.5\textwidth}
    %         \lstinputlisting[title=Eliminación de universal]{listings/interfaz/by-forall.ppa}
    %     \end{column}
    % \end{columns}

%\end{frame}

% \begin{frame}[fragile]{Have}
%     \pause
%     \begin{block}{Hipótesis anterior implícita}
%         Ambas pueden referirse a la hipótesis anterior con guión medio
%         (\lstinline{-}), y pueden hacerlo implícitamente usando \lstinline{hence} y
%         \lstinline{then}.
    
%         \begin{table}[H]
%             \centering
%         \begin{tabular}{l|l|l}
%         Comando             & Alternativo             & ¿Reduce la tesis? \\
%         \hline
%         \lstinline|thus|    & \lstinline|hence|       & Sí               \\
%         \lstinline|have|    & \lstinline|then|        & No              
%         \end{tabular}
%         \end{table}    
%     \end{block}
%     % \begin{figure}[H]
%     %     \centering
%     %     \small Eliminación de implicación en dos pasos
        
%     %     \begin{tabular}{c}
%     %         \lstinputlisting{listings/interfaz/by-imp-have.ppa}
%     %     \end{tabular}
%     % \end{figure}
%     % \begin{columns}
%     %     \begin{column}{0.5\textwidth}
%     %     \lstinputlisting[
%     %         firstline=1,
%     %         lastline=9,
%     %         title=Eliminación en dos pasos,
%     %     ]{listings/interfaz/by-imp-then.ppa}
%     %     \end{column}
%     %     \begin{column}{0.5\textwidth}
%     %         \lstinputlisting[
%     %             linerange={12-16, 19-23},
%     %             numbers=none,
%     %             title=Alternativas equivalentes,
%     %         ]{listings/interfaz/by-imp-then.ppa}
%     %     \end{column}
%     % \end{columns}

% \end{frame}
% \begin{frame}[fragile]{By opcional}
%     \begin{itemize}
%         \item El \lstinline{by} es opcional
%         \item Si se omite, la fórmula debe ser
%         demostrable por el \textit{solver} sin partir de ninguna hipótesis
%         \item Vale para todas las tautologías proposicionales.
%     \end{itemize}

%     \begin{figure}[H]
%         \centering
%         \small Tautología proposicional
        
%         \begin{tabular}{c}
%             \lstinputlisting{listings/interfaz/by-taut.ppa}
%         \end{tabular}
%     \end{figure}
% \end{frame}

\begin{frame}{Comandos y reglas de inferencia}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{table}[H]
                \centering
                \begin{tabular}{c|c}
                Regla & Comando \\
                \hline
                \ruleLEM        &   \lstinline|cases| \\
                \ruleAx         &   \lstinline|by| \\
                \ruleExistsI    &   \lstinline|take| \\
                \ruleExistsE    &   \lstinline|consider| \\
                \ruleForallI    &   \lstinline|let| \\
                \ruleForallE    &   \lstinline|by| \\
                \ruleOrIOne     &   \lstinline|by| \\
                \ruleOrITwo     &   \lstinline|by| \\
                \ruleOrE        &   \lstinline|cases|
                \end{tabular}
            \end{table}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{table}[H]
                \centering
                \begin{tabular}{c|c}
                Regla & Comando \\
                \hline
                \ruleAndI       &   \lstinline|by| \\
                \ruleAndEOne    &   \lstinline|by| \\
                \ruleAndETwo    &   \lstinline|by| \\
                \ruleImpI       &   \lstinline|suppose| \\
                \ruleImpE       &   \lstinline|by| \\
                \ruleNotI       &   \lstinline|suppose| \\
                \ruleNotE       &   \lstinline|by| \\
                \ruleTrueI      &   \lstinline|by| \\
                \ruleFalseE     &   \lstinline|by|
                \end{tabular}
            \end{table}
        \end{column}
    \end{columns}
    \pause
    Adicionales:
    \begin{itemize}
        \item \lstinline{equivalently}: Reduce la tesis a una fórmula equivalente.
        \item \lstinline{claim}: Análogo a \lstinline{have} pero con una sub-demostración.
    \end{itemize}
\end{frame}

% \begin{frame}[fragile]{Suppose (\ruleImpI / \ruleNotI)}
%     \begin{command}
%         \lstinline{suppose <name>: <form>} \quad (\ruleImpI / \ruleNotI)
%     \end{command}

%     \begin{itemize}
%         \item  Si la tesis es una implicación $\form \fImp \formTwo$, agrega el antecedente
%         $\form$ como hipótesis con el nombre dado y reduce la tesis al consecuente
%         $\formTwo$
%         \item Viendo la negación como una implicación $\fNot \form \equiv
%         \form \fImp \fFalse$, permite introducir negaciones, tomando
%         $\formTwo = \fFalse$.
%     \end{itemize}

%     \begin{columns}
%         \begin{column}{0.5\textwidth}
%             \lstinputlisting[
%                 firstline=1, lastline=7,
%                 title=Introducción de implicación,
%             ]{listings/interfaz/suppose.ppa}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \lstinputlisting[
%                 firstline=9, lastline=15,
%                 title=Introducción de negación,
%             ]{listings/interfaz/suppose.ppa}    
%         \end{column}
%     \end{columns}
% \end{frame}

% \begin{frame}[fragile]{Cases (\ruleOrE)}
%     \begin{command}
%         \lstinline{cases by <h1>, ..., <hn>} \quad (\ruleImpI / \ruleNotI)
%     \end{command}
%     \begin{columns}
%         \begin{column}{0.5\textwidth}
%         \begin{itemize}
%             \item Permite razonar por casos a partir de una disyunción. Para cada uno, se debe
%             demostrar la tesis en su totalidad.
%             \item Si los casos son \lstinline{<f1>} a
%             \lstinline{<fn>}, tiene que valer \lstinline{<f1> | ... | <fn> by} \lstinline{<h1>, ..., <hn>}.
%             \item Se puede omitir el \lstinline{by} para razonar mediante LEM (casos $\anyForm$ y $\fNot \anyForm$).
%         \end{itemize}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \lstinputlisting[
%         title=Cases,
%         firstline=1, lastline=11,
%     ]{listings/interfaz/cases.ppa}
%         \end{column}
%     \end{columns}
% \end{frame}

% \begin{frame}[fragile]{Take (\ruleExistsI)}
%     \begin{command}
%         \lstinline{take <var> := <term>} \quad (\ruleExistsI)
%     \end{command}
%     \vfill
%     \begin{itemize}
%         \item Introduce un existencial instanciando su variable y reemplazándola por un término.
%         \item Si la tesis es \lstinline{exists X . p(X)}, luego de \lstinline{take X := a}, se reduce a \lstinline{p(a)}.
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Consider (\ruleExistsE)}
%     \begin{command}
%         \lstinline{consider <var> st <name>: <form> by <h1>, ..., <hn>} \quad (\ruleExistsE)
%     \end{command}
%     \begin{itemize}
%         \item Si se puede justificar \lstinline{exists X. p(X)}, permite razonar sobre tal \lstinline{X}.
%         \item Agrega \lstinline{<form>} como hipótesis al contexto, con nombre \lstinline{<name>}. No reduce la tesis.
%         \item Debe valer \lstinline{exists <var> . <form> by <h1>, ..., <hn>}
%         \item Permite $\alpha$-equivalencias: Si podemos justificar \lstinline{exists X. p(X)}, podemos usarlo como \lstinline{consider Y st h: p(Y) by ...}.
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Let (\ruleForallI)}
%     \begin{command}
%         \lstinline{let <var>} \quad (\ruleForallI)
%     \end{command}
%     \begin{itemize}
%         \item Permite demostrar un cuantificador universal.
%         \item Si la tesis es \lstinline{forall X . p(X)}, luego de \lstinline{let X}, la tesis se reduce a \lstinline{p(X)}.
%         \item Permite renombrar la variable, por ejemplo luego de \lstinline{let Y} la tesis se reduce a \lstinline{p(Y)}.
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Comandos adicionales}
%     \begin{command}
%         \lstinline{equivalently <form>}

%         Permite reducir la tesis a una fórmula equivalente
%     \end{command}

%     \begin{command}
%         \lstinline{claim <name>: <form>}

%         Análogo a \lstinline{have} pero con una sub-demostración.
%     \end{command}

%     \begin{lstlisting}[numbers=none, title=Esquema de claim]
% theorem t: <form1>
% proof
%     claim <name>: <form2>
%     proof
%         // Demostración de <form2>.
%     end
%     // Demostración de <form1> refiriéndose a <name>.
% end
%     \end{lstlisting}

%     \begin{itemize}
%         \item Permite reducir la tesis a una fórmula equivalente
%         \item Se puede usar por ejemplo para descarga de conjunciones, o para razonar por el absurdo mediante la eliminación de la doble negación.
%     \end{itemize}

%     \begin{columns}
%         \begin{column}{0.5\textwidth}
%             \lstinputlisting[title=Descarga de conjunción]{listings/interfaz/equivalently.ppa}
%         \end{column}
%         \begin{column}{0.5\textwidth}
% \begin{lstlisting}[numbers=none,title=Razonamiento por el absurdo]
% theorem t: <form>
% proof
%     equivalently ~~<form>
%     suppose <name>: ~<form>
%     // Demostración de <form>
%     // por el absurdo,
%     // asumiendo ~<form>
%     // y llegando a una
%     // contradicción (false).
% end
% \end{lstlisting}
%         \end{column}
%     \end{columns}
%\end{frame}

\section{Certificador}

\begin{frame}{Certificados}
    \begin{columns}
        
        \begin{column}{0.5\textwidth}
            \begin{itemize}
                \item Las demostraciones de \ppaLang{} se \textit{certifican} generando
                una demostración de deducción natural.
                \item Evita confiar en la implementación del asistente.
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            
            \begin{figure}
                \includegraphics[scale=0.32]{img/ppt/certify.png}
                \centering
                \title{Arquitectura del certificador}
            \end{figure}
        \end{column}
    \end{columns}
    \pause
    \begin{block}{Criterio de de Bruijn}
        Un asistente de demostración cumple con el criterio de de Bruijn si
        satisface que sus demostraciones puedan ser chequeadas por un programa
        independiente, pequeño y confiable.
    \end{block}
\end{frame}


\begin{frame}{Certificado de demostraciones}
    El certificado de una demostración es recursivo:
    % se certifica cada comando, generando una demostración en deducción natural cuyas premisas son el certificado del resto de la demostración en PPA.
    \begin{figure}
        \begin{columns}
            \begin{column}{0.45\textwidth}
                \begin{tabular}{c}
                    \lstinputlisting{listings/ppt/certificado.ppa}
                \end{tabular}
    
            \end{column}
            \begin{column}{0.35\textwidth}
                \begin{prooftree}
                    \AxiomC{}
                    \RL{\alert{\ruleAxh{h}}}
                    \UnaryInfC{$h: p(v) \judG p(v)$}
                    \RL{\ruleExistsI}
                    \UnaryInfC{$h: p(v) \judG \exists x . p(X)$}
                    \RL{\ruleImpIh{h}}
                    \UnaryInfC{$\judG p(v) \fImp \exists x . p(X)$}
                \end{prooftree}
    
            \end{column}
        \end{columns}
        \caption{Ejemplo de certificado generado para un programa}
    \end{figure}
\end{frame}

\begin{frame}{Contexto global}
    Se generan $N$ demostraciones de deducción natural para cada programa, y se guardan en el \textit{contexto global}. El chequeo se extiende a contextos.
    
    \begin{figure}
        \begin{columns}
            \begin{column}{0.4\textwidth}
                \begin{tabular}{c}
                    \lstinputlisting{listings/certifier/two-theorems.ppa}
                \end{tabular}
            \end{column}
            \begin{column}{0.3\textwidth}
                \includegraphics[scale=0.4]{img/ppa-context.png}
            \end{column}
        \end{columns}
        \caption{Contexto resultante de certificar un programa}
    \end{figure}
\end{frame}


\begin{frame}{Contexto local}
    Cada demostración tiene un contexto local a ella con las hipótesis agregadas por ciertos comandos (\lstinline{suppose}, \lstinline{consider}, \lstinline{have}, \lstinline{claim}, etc.).

    \begin{figure}[h]
        \centering
        \begin{columns}
            \begin{column}{0.5\textwidth}
                \begin{tabular}{c}
                    \lstinputlisting{listings/certifier/local-context.ppa}
                \end{tabular}
            \end{column}
            \begin{column}{0.35\textwidth}
                \includegraphics[scale=0.33]{img/ppa-local-context.png}
            \end{column}
        \end{columns}
        \caption{Ejemplo de contexto local}
    \end{figure}
\end{frame}

\begin{frame}{Certificado del by}
    Teniendo $\ctx = \{\hypId_1: \formTwo_1, \dots, \hypId_n: \formTwo_n\}$, para \lstinline{thus A by h1, ..., hn}:

    \begin{enumerate}[<+->]
        \item Buscamos las hipótesis en el contexto. Queremos demostrar
        \[
            \formTwo_1 \fAnd \dots \fAnd \formTwo_n \fImp \form
        \]
        \item \textbf{Razonamos por el absurdo}: Asumiendo la negación buscamos una contradicción
        \begin{align*}
            \fNot (\formTwo_1 \fAnd \dots \fAnd \formTwo_n \fImp \form)
            &\equiv \fNot (\fNot (\formTwo_1 \fAnd \dots \fAnd \formTwo_n) \fOr \form)\\
            &\equiv \formTwo_1 \fAnd \dots \fAnd \formTwo_n \fAnd \fNot \form
        \end{align*}
        \item Convertimos la negación a forma normal disyuntiva (\textbf{DNF})
        \[
            (\formLit_{1} \fAnd \dots \fAnd \formLit_n)
            \fOr \dots \fOr
            (\formLitTwo_{1} \fAnd \dots \fAnd \formLitTwo_m)
        \]
        \item Buscamos una \textbf{contradicción} refutando cada cláusula individualmente. Será refutable si
        \begin{itemize}
            \item Contiene $\fFalse$ o dos fórmulas opuestas ($\formLit, \fNot \formLit$), 
            \item Eliminando existenciales consecutivos y reiniciando el proceso, se consigue una refutación ($\fNot \pred(k), \forall \var . \pred(\var)$)
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{Ejemplo sin cuantificadores (1/2)}
    \begin{figure}
        \centering
        \small By sin cuantificadores

        \vspace{0.1cm}
        \begin{tabular}{c}
            \lstinputlisting{listings/certifier/by-modus-ponens.ppa}
        \end{tabular}
    \end{figure}
    \pause
    \begin{enumerate}[<+->]
        \item Para certificar \lstinline{thus b by ax1, ax2} hay que generar una
        demostración para la implicación \[\big((a \fImp b) \wedge a \big)\fImp b\]
        \item Negamos la fórmula y buscamos una contradicción.
        \[ \fNot [ \big( (a \to b) \fAnd a \big) \to b ] \]
    \end{enumerate}
\end{frame}
\begin{frame}{Ejemplo sin cuantificadores (2/2)}
    \begin{enumerate}[<+->]
        \setcounter{enumi}{2}
        \item La convertimos a DNF
        \begin{align*}
            &\fNot [ \big( (a \to b) \fAnd a \big) \to b ] \\
            &\equiv \fNot [ \fNot \big( (a \to b) \fAnd a \big) \fOr b ]
                && \just{\form \to \formTwo \equiv \fNot \form \fOr \formTwo}\\
            &\equiv \fNot \fNot \big( (a \to b) \fAnd a \big) \fAnd \fNot b
                && \just{\fNot(\form \fOr \formTwo) \equiv \fNot \form \fAnd \fNot \formTwo}\\
            &\equiv \big( (a \to b) \fAnd a \big) \fAnd \fNot b
                && \just{\fNot\fNot \form \equiv \form}\\
            &\equiv (\fNot a \fOr b) \fAnd a \fAnd \fNot b
                 && \just{\form \to \formTwo \equiv \fNot \form \fOr \formTwo}\\
            &\equiv (\fNot a \fOr b) \fAnd a \fAnd \fNot b
                && \just{(\form \fOr \formTwo) \fAnd \formThree \equiv (\form \fAnd \formThree) \fOr (\formTwo \fAnd \formThree)}\\
            &\equiv \begin{aligned}[t]
                &(\fNot a \fAnd a \fAnd \fNot b)\ \vee\\
                &(b \fAnd a \fAnd \fNot b)
            \end{aligned}
        \end{align*}
        \item Refutamos cada cláusula
        \[
            (\alert{\fNot a} \fAnd \alert{a} \fAnd \fNot b) \vee
            (\alert{b} \fAnd a \fAnd \alert{\fNot b})
        \]
        \qed
    \end{enumerate}
\end{frame}

\begin{frame}{Ejemplo con cuantificadores (1/3)}
    \begin{figure}[H]
        \centering
        \small By con cuantificadores

        \vspace{0.1cm}    
        \begin{tabular}{c}
            \lstinputlisting{listings/ppt/by-modus-ponens-quant.ppa}
        \end{tabular}
    \end{figure}
    \pause
    \begin{enumerate}[<+->]
        \item Para certificar \lstinline{thus q(k) by ax1, ax2} hay que generar una
        demostración para la implicación \[
            \Big(\big(\forall x. (p(x) \fImp q(x))\big) \fAnd p(k) \Big)
            \fImp q(k)
        \]
        \item Negamos la fórmula 
        \[
            \fNot \left[
            \Big(\big(\forall x. (p(x) \fImp q(x))\big) \fAnd p(k) \Big)
            \fImp q(k)
        \right]
        \]
    \end{enumerate}
\end{frame}

\begin{frame}{Ejemplo con cuantificadores (2/3)}
    \begin{enumerate}[<+->]
        \setcounter{enumi}{2}
        \item La convertimos a DNF
        \begin{align*}
            &\fNot \left[
                \Big(\big(\forall x. (p(x) \fImp q(x))\big) \fAnd p(k) \Big)
                \fImp q(k)
            \right] \\
            &\equiv \fNot \left[
                \fNot \Big(\big(\forall x. (p(x) \fImp q(x))\big) \fAnd p(k) \Big)
                \fOr q(k)
            \right] \\
            &\equiv
                \fNot \fNot \Big(\big(\forall x. (p(x) \fImp q(x))\big) \fAnd p(k) \Big)
                \fAnd \fNot q(k)\\
            &\equiv \big(\forall x. (p(x) \fImp q(x))\big) \fAnd p(k)
            \fAnd \fNot q(k)
        \end{align*}

        como a los ojos de DNF un $\forall$ es opaco, a pesar de que dentro
        tenga una implicación, la fórmula ya está en forma normal.

        \item Buscamos una contradicción refutando cada cláusula. No hay forma
        encontrando literales opuestos o $\fFalse$, por ej. la cláusula
        $p(a)$ no es refutable.
    \end{enumerate}
\end{frame}

\begin{frame}{Ejemplo con cuantificadores (3/3)}
    \begin{enumerate}[<+->]
        \setcounter{enumi}{4}
        \item Probamos eliminando $\forall x. (p(x) \fImp q(x))$. Reemplazamos
        $x$ por una meta-variable fresca $\metavar{u}$.
        \[
            (p(\metavar{u}) \fImp q(\metavar{u})) \fAnd p(k) \fAnd \fNot q(k)
        \]
        \item Convertimos a DNF
        \begin{align*}
            &(p(\metavar{u}) \fImp q(\metavar{u})) \fAnd p(k) \fAnd \fNot q(k)\\
            &\equiv (\fNot p(\metavar{u}) \fOr q(\metavar{u})) \fAnd p(k) \fAnd \fNot q(k)\\
            &\equiv ( (\fNot p(\metavar{u}) \fAnd p(k)) \fOr (q(\metavar{u}) \fAnd p(k))) \fAnd \fNot q(k)\\
            &\equiv 
            \begin{aligned}[t]
                &(\fNot p(\metavar{u}) \fAnd p(k) \fAnd \fNot q(k))\ \fOr\\
                &(q(\metavar{u}) \fAnd p(k)\fAnd \fNot q(k))
            \end{aligned}
        \end{align*}
        \item Buscamos una contradicción refutando cada cláusula. Los
        literales opuestos tienen que \textit{unificar} en lugar de ser iguales.
        \begin{itemize}
            \item $\alert{\fNot p(\metavar{u})} \fAnd \alert{p(k)} \fAnd \fNot q(k)$ tenemos $p(\metavar{u}) \unify p(k)$ con $\subst{\metavar{u}}{k}$
            \item $\alert{q(\metavar{u})} \fAnd p(k) \fAnd \alert{\fNot q(k)}$ tenemos $q(\metavar{u}) \unify q(k)$ con $\subst{\metavar{u}}{k}$
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{Deducción natural}
    \begin{alertblock}{Desafío}
        ¡Hay que generar una demostración en deducción natural!
    \end{alertblock}

    Pasos

    \begin{itemize}
        \item \textbf{Razonamiento por el absurdo}: mediante las \textit{reglas admisibles} cut y eliminación de la doble negación (\ruleDnegE).
        \item \textbf{Conversión a DNF}: mediante la implementación de un \textit{sistema de reescritura}.
        \item \textbf{Contradicciones}: mediante la \textit{regla admisible} \ruleAndEProj{\anyForm} + \ruleOrE{} + \ruleNotI{}.
        \item \textbf{Eliminación de cuantificadores universales}: mediante unificación y \ruleForallE{}.
    \end{itemize}
\end{frame}

\begin{frame}{Razonamiento por el absurdo}
    \begin{exampleblock}{Razonamiento por el absurdo en DNF}
        \[
        \judG \formTwo_1 \fAnd \dots \fAnd \formTwo_n \fImp \form
        \overset{?}{\rightsquigarrow}
        \fNot (\formTwo_1 \fAnd \dots \fAnd \formTwo_n \fImp \form) \judG \fFalse
    \]
    \end{exampleblock}
    \pause
    \begin{columns}
        \begin{column}{0.4\textwidth}
            \begin{theorem}[DNeg Elim]
                \begin{prooftree}
                    \AxiomC{}
                    \RL{\ruleDnegE}
                    \admissibleRuleLine
                    \UnaryInfC{$\fNot \fNot \form \judG \form$}
                \end{prooftree}
            \end{theorem}        
        \end{column}
        % "Cortar el flujo de la demostración"
        \begin{column}{0.4\textwidth}
            \begin{theorem}[cut]
                \begin{prooftree}
                    \AxiomC{$\ctx, \formTwo \judG \form$}
                    \AxiomC{$\ctx \judG \formTwo$}
                    \RL{\ruleCut}
                    \admissibleRuleLine
                    \BinaryInfC{$\ctx \judG \form$}
                \end{prooftree}
            \end{theorem}
        \end{column}
    \end{columns}
    \begin{lemma}[Razonamiento por el absurdo]
        \begin{prooftree}
            \AxiomC{$\vdots$}
            \noLine
            \UnaryInfC{$\ctx, \fNot \form \judG \fFalse$}
            \RL{\ruleNotI}
            \UnaryInfC{$\ctx \judG \fNot\fNot \form$}
            \RL{\ruleCutWith{\ruleDnegE}}
            \admissibleRuleLine
            \UnaryInfC{$\ctx \judG \form$}
        \end{prooftree}
        \vspace{0.1cm}
    \end{lemma}
    
\end{frame}

\begin{frame}{Conversión a DNF}
    Implementamos una traducción mediante el siguiente sistema de reescritura. \textbf{Algoritmo}: reescribir de a un paso hasta que no cambie (clausura de Kleene)
        \begin{align*}
            \fNot\fNot \formLit &\rewrite
                \formLit
                &&\text{eliminación de $\fNot\fNot$}\\
            \fNot \fFalse &\rewrite
                \fTrue\\
            \fNot \fTrue &\rewrite
                \fFalse\\
            \formLit \fImp \formLitTwo &\rewrite
                \fNot \formLit \fOr \formLitTwo
                &&\text{definición de implicación}\\
            \fNot(\formLit \fOr \formLitTwo) &\rewrite
                \fNot \formLit \fAnd \fNot \formLitTwo
                &&\text{distributiva de $\fNot$ sobre $\fAnd$}\\
            \fNot(\formLit \fAnd \formLitTwo) &\rewrite
                \fNot \formLit \fOr \fNot \formLitTwo
                &&\text{distributiva de $\fNot$ sobre $\fOr$}\\
            (\formLit \fOr \formLitTwo) \fAnd \formLitThree &\rewrite
                (\formLit \fAnd \formLitThree) \fOr (\formLitTwo \fAnd \formLitThree)
                &&\text{distributiva de $\fAnd$ sobre $\fOr$ (der)}\\
            \formLitThree \fAnd (\formLit \fOr \formLitTwo) &\rewrite
                (\formLitThree \fAnd \formLit) \fOr (\formLitThree \fAnd \formLitTwo)
                &&\text{distributiva de $\fAnd$ sobre $\fOr$ (izq)}\\
            \formLit \fOr (\formLitTwo \fOr \formLitThree) &\rewrite
                (\formLit \fOr \formLitTwo) \fOr \formLitThree
                &&\text{asociatividad de $\fOr$}\\
            \formLit \fAnd (\formLitTwo \fAnd \formLitThree) &\rewrite
                (\formLit \fAnd \formLitTwo) \fAnd \formLitThree
                &&\text{asociatividad de $\fAnd$}
        \end{align*}
\end{frame}

\begin{frame}{Conversión a DNF - Congruencias}
    Para reescribir una sub-fórmula (trivial sintácticamente), hay que demostrar las congruencias de los conectivos.
    \[
        \formLit \fOr \alert{\fNot (\formLitTwo \fOr \formLitThree)}
        \judG
        \formLit \fOr \alert{(\fNot \formLitTwo \fAnd \fNot \formLitThree)}
    \]\pause
    \vspace{-0.3cm}
    \begin{block}{Congruencias}
        \vspace{-0.3cm}
        \begin{gather*}
        \form \judG \form'
        \Rightarrow \form \fAnd \formTwo \judG \form' \fAnd \formTwo
        \qquad
        \formTwo \judG \formTwo'
        \Rightarrow \form \fAnd \formTwo \judG \form \fAnd \formTwo'
        \\
        \form \judG \form'
        \Rightarrow \form \fOr \formTwo \judG \form' \fOr \formTwo
        \qquad
        \alert{\formTwo \judG \formTwo'
        \Rightarrow \form \fOr \formTwo \judG \form \fOr \formTwo'}
        \\
        \form' \judG \form
        \Rightarrow \fNot \form \judG \fNot \form'
        \end{gather*}        
    \end{block}
    \pause
    \begin{alertblock}{$\fNot$ es contravariante}
        Para demostrar $\fNot \form \judG \fNot \form'$ no necesitamos una demostración de $\form \judG \form'$ (\textit{covariante}), sino de $\form' \judG \form$ (\textit{contravariante}).
        \pause

        $\Rightarrow$ para todas las reescrituras, incluso las congruencias, tenemos que demostrarlas en ambos sentidos.
    \end{alertblock}
\end{frame}

\begin{frame}{Conversión a DNF - Reglas admisibles}
    \begin{block}{Reglas admisibles para conversión a DNF}
        \begin{columns}[t]
        \begin{column}{0.5\textwidth}
            \centering
            Pasos base
            \begin{align*}
            \fNot\fNot \formLit &\judgEquiv
                \formLit
                \\
            \fNot \fFalse &\judgEquiv
                \fTrue\\
            \fNot \fTrue &\judgEquiv
                \fFalse\\
            \formLit \fImp \formLitTwo &\judgEquiv
                \fNot \formLit \fOr \formLitTwo
                \\
            \fNot(\formLit \fOr \formLitTwo) &\judgEquiv
                \fNot \formLit \fAnd \fNot \formLitTwo
                \\
            \fNot(\formLit \fAnd \formLitTwo) &\judgEquiv
                \fNot \formLit \fOr \fNot \formLitTwo
                \\
            (\formLit \fOr \formLitTwo) \fAnd \formLitThree &\judgEquiv
                (\formLit \fAnd \formLitThree) \fOr (\formLitTwo \fAnd \formLitThree)
                \\
            \formLitThree \fAnd (\formLit \fOr \formLitTwo) &\judgEquiv
                (\formLitThree \fAnd \formLit) \fOr (\formLitThree \fAnd \formLitTwo)
                \\
            \formLit \fOr (\formLitTwo \fOr \formLitThree) &\judgEquiv
                (\formLit \fOr \formLitTwo) \fOr \formLitThree
                \\
            \formLit \fAnd (\formLitTwo \fAnd \formLitThree) &\judgEquiv
                (\formLit \fAnd \formLitTwo) \fAnd \formLitThree
            \end{align*}
        \end{column}
        \begin{column}{0.5\textwidth}
            \centering
            Pasos recursivos de congruencia
            
            (con $\form \judgEquiv \form'$)
            \begin{align*}
                \form \fAnd \formTwo &\judgEquiv \form' \fAnd \formTwo\\
                \form \fOr \formTwo &\judgEquiv \form' \fOr \formTwo\\
                \fNot \form &\judgEquiv \fNot \form'
            \end{align*}
            \vspace{0.5cm}
            \begin{center}
                \textbf{¡26 demostraciones!}
            \end{center}
        \end{column}
        \end{columns}
    \end{block}
\end{frame}

\begin{frame}{Contradicciones}
    \begin{exampleblock}{Ejemplo}
    \begin{prooftree}
        \def\defaultHypSeparation{\hskip .1in}
        \AxiomC{}
        \LL{\ruleAx}
        \UnaryInfC{\(
            \ctx \judG
            \begin{aligned}[b]
                &(\fNot a \fAnd a \fAnd \fNot b)\\
                &\vee (b \fAnd a \fAnd \fFalse)
            \end{aligned}
        \)}
        \AxiomC{$\someProof_L$}
        \noLine
        \UnaryInfC{\(
            \ctx, \fNot a \fAnd a \fAnd \fNot b \judG \fFalse
        \)}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\ctx_1 \judG b \fAnd a \fAnd \fFalse$}
        \RL{\ruleAndEProj{\fFalse}}
        \admissibleRuleLine
        \UnaryInfC{\(
            \ctx, b \fAnd a \fAnd \fFalse \judG \fFalse
        \)}
        \RL{\ruleOrE}
        \TrinaryInfC{\(
            \ctx = (\fNot a \fAnd a \fAnd \fNot b)
            \vee
            (b \fAnd a \fAnd \fFalse)
            \judG
            \fFalse
        \)}
    \end{prooftree}
    
    donde
    
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\ctx_1 \judG \fNot a \fAnd a \fAnd \fNot b$}
        \RL{\ruleAndEProj{\fNot a}}
        \admissibleRuleLine
        \UnaryInfC{$\ctx_1 \judG \fNot a$}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\ctx_1 \judG \fNot a \fAnd a \fAnd \fNot b$}
        \RL{\ruleAndEProj{a}}
        \admissibleRuleLine
        \UnaryInfC{$\ctx_1 \judG a$}
        \RL{\ruleNotE}
        \LL{$\someProof_L=$}
        \BinaryInfC{\(
            \ctx_1 = \ctx, b \fAnd a \fAnd \fFalse \judG \fFalse
        \)}
    \end{prooftree}
    \end{exampleblock}
    \pause
    \begin{lemma}[Regla admisible \ruleAndEProj{\anyForm}]
        \begin{prooftree}
            \AxiomC{$\ctx \judG \anyForm_1 \fAnd \dots \fAnd \anyForm_i \fAnd \dots \fAnd \anyForm_n$}
            \AxiomC{$n \in \setNaturals$}
            \admissibleRuleLine
            \RL{\ruleAndEProj{\anyForm_{i}}}
            \BinaryInfC{$\ctx \judG \anyForm_i$}
        \end{prooftree}
    \end{lemma}
\end{frame}

\begin{frame}[fragile]{Alcance y limitaciones del by}
    \begin{itemize}
        \item \textbf{Completo} para lógica proposicional y \textbf{heurístico} para primer orden.
        \item Esto es aceptable, la validez de LPO es indecidible (Teorema de Church).
        \item Elimina los $\forall$ consecutivos de a lo sumo una hipótesis. Pero le faltan más cosas.
    \end{itemize}
\begin{figure}
    \centering
    \small Ejemplo de falla en eliminación
    \vspace{0.1cm}

    \begin{tabular}{c}
\begin{lstlisting}
axiom ax1: forall X . p(X) -> q(X)
axiom ax2: forall X . p(X)
theorem t: q(a)
proof
    thus q(a) by ax1, ax2
end
\end{lstlisting}
    \end{tabular}
\end{figure}
\end{frame}

% Considerar saltear esto si no da el tiempo

\begin{frame}[fragile]{Descarga de conjunciones}
    Si la tesis es una conjunción, se puede probar un subconjunto de ella y se reduce el resto.
    \lstinputlisting[title=Descarga]{listings/interfaz/discharge-complex.ppa}
\end{frame}
\begin{frame}{Descarga de conjunciones}
    \todo{Agregar esto}
\end{frame}

\section{Extracción de testigos}

% \begin{frame}{Intuición del problema}
%     \begin{figure}
%         \includegraphics[scale=0.28]{img/ppt/extraction.png}
%     \end{figure}
% \end{frame}

\begin{frame}{Extracción simple}
    \lstinputlisting[title=Extracción simple]{listings/ppt/extract/exists.ppa}
    \pause
    \begin{command}
        \lstinline{take <var> := <term>}
        \proofTreeExistsI
    \end{command}
\end{frame}


\begin{frame}{Extracción indirecta con instanciación}
    \lstinputlisting[title=Extracción con instanciación]{listings/ppt/extract/forall.ppa}
\end{frame}

% \begin{frame}
%     \lstinline{theorem todo_numero_tiene_leq: forall N. exists M . M <= N}

%     Extraemos un testigo \lstinline{cero} y podemos instanciar \lstinline{N} en lo que sea, por ej. \lstinline{cero <= 60}
% \end{frame}

% \begin{frame}{Extracción indirecta}
%     \lstinputlisting[title=Extracción indirecta]{listings/ppt/extract/indirect.ppa}
%     Extracción \textbf{indirecta} de \lstinline{theorem t2} nos da el testigo \lstinline{juan}.
% \end{frame}

\begin{frame}{Extracción por el absurdo}
    \lstinputlisting[
        title=Extracción por el absurdo,
        firstline=1,
        lastline=9,
    ]{listings/ppt/abs-ppt-narrow.ppa}
    \begin{itemize}
        \item En general $\exists \var . \anyForm \equiv \fNot \forall \var .\fNot \anyForm$.
        \item Sin \lstinline{take} (\ruleExistsI) explícito, igual podemos extraer el testigo a partir del \lstinline{theorem} \lstinline{hayAlguienBajo}: \lstinline{juan}.
        \item \alert{La implementación no es tan directa como buscar un \ruleExistsI} en el árbol de la demostración.
    \end{itemize}
    
\end{frame}

\begin{frame}{Lógica clásica}
    \begin{figure}
        \includegraphics[scale=0.3]{img/ppt/extraction-candidate.png}
    \end{figure}
    \begin{itemize}[<+->]
        \item Buscamos un mecanismo general que nos permita extraer testigos a partir de demostraciones en \textbf{deducción natural clásica}
        \item Pero la lógica clásica \textbf{no es constructiva}, por LEM:
        \vspace{0.5cm}
        \proofTreeLEM
    \end{itemize}
%     \begin{block}{Mecanismo de extracción de testigos}
%         A partir de una demostración en PPA para una fórmula de la forma \[\forall \var_0 \dots \forall \var_n
% \exists \varTwo . \anyForm(\var_0, \dots, \var_n, \varTwo),\]

% \begin{enumerate}
%     \item la certifique generando una demostración en \alert<2>{deducción natural \textbf{clásica}}
%     \item  a partir de ella extraiga $\termTwo$ tal que, para $\term_0, \dots, \term_n$ cuales quiera, valga \[\anyForm(\term_0, \dots, \term_n, \termTwo)\]
% \end{enumerate}
%     \end{block}
\end{frame}

% \begin{frame}{Demostración no constructiva}
%     \begin{theorem}
%         Existen dos números irracionales $a$ y $b$ tales que $a^b$ es racional.
%     \end{theorem}
%     \begin{proof}
%         Considerar el número $\sqrt{2}^{\sqrt{2}}$. Por LEM, es o bien racional o
%     irracional.
%     \begin{itemize}
%         \item Supongamos que es racional. Como sabemos que $\sqrt{2}$ es
%               irracional, podemos tomar $a=b=\sqrt{2}$ que por hipótesis es racional.
%         \item Supongamos que es irracional. Tomamos $a = \sqrt{2}^{\sqrt{2}}, b
%                   = \sqrt{2}$. Ambos son irracionales, y tenemos

%               \[
%                   a^b
%                   = \left( \sqrt{2}^{\sqrt{2}} \right)^{\sqrt{2}}
%                   = \sqrt{2}^{\sqrt{2} \cdot \sqrt{2}}
%                   = \sqrt{2}^{2}
%                   = 2,
%               \]

%               que es racional.
%     \end{itemize}

%     En ambos casos podemos encontrar $a, b$ tales que $a^b$ es racional.
%     \end{proof}
    % \begin{itemize}
    %     \item ¡No nos dice quienes son $a$ y $b$! Complica la extracción de testigos.
    %     \item Pero podría: $a = \sqrt{2}$ y $b = 2 \log_2{3}$. \alert{No siempre}.
    % \end{itemize}
% \end{frame}

\begin{frame}{Demostración no constructiva}
    \begin{ejemplo}[Fórmula sin demostración constructiva]
        Sea $C$ algo indecidible (tipo \texttt{HALT}), queremos ver que vale
        \[
            \exists y .
                (y = 1 \fAnd \alert{C})
                \fOr
                (y = 0 \fAnd \alert{\fNot C})
        \]
        \pause
        podemos demostrarlo por LEM, sabemos que vale $C \fOr \fNot C$

        \begin{itemize}
            \item Supongamos que vale $C$. Tomo $y = 1$.
            \item Supongamos que vale $\fNot C$. Tomo $y = 0$. \qed
        \end{itemize}
        
        \pause
        ¡No nos dice cual es cierto! No es \textit{constructiva}. No tenemos forma de saber si es cierto $C$ o $\fNot C$ (indecidible).
    \end{ejemplo}
    \pause
    ¿Entonces por qué lógica clásica?
    \begin{itemize}
        \item Existen fórmulas que admiten demostraciones constructivas y no constructivas, y otras \textit{solo no constructivas} (i.e. clásicas).
        \item Además permite razonar por el absurdo, con \ruleDnegE{} $\equiv$ \ruleLEM{}
    \end{itemize}

    % \begin{theorem}[Teorema constructivo y no constructivo]
    %     Existen dos números irracionales $a$ y $b$ tales que $a^b$ es racional.
    % \end{theorem}
\end{frame}

\begin{frame}{Clases de estrategias de extracción}
    \begin{figure}
        \centering
        \includegraphics[scale=0.25]{img/ppt/extract-strategies.png}
    \end{figure}
    Clases de estrategias de extracción de demostraciones en lógica clásica:
    \begin{itemize}
        \item \textbf{Directas}: Extraer directamente de demostraciones clásicas. Técnicas de \textit{realizabilidad clásica} (Semánticas de $\lambda$-cálculos clásicos).
        \item \textbf{Indirectas}: Convertir la demostración a una lógica que se porte mejor y extraer de ahí.
    \end{itemize}
\end{frame}


\begin{frame}{Lógica intuicionista}
    \begin{center}
        \textbf{lógica intuicionista} = lógica clásica $-$ \ruleLEM{}
    \end{center}

    Características:
    
    \begin{itemize}
        \item No tiene LEM\footnote{Ni principios de razonamiento equivalentes, como \ruleDnegE{}}, entonces siempre es constructiva.
        \item Siempre permite hacer extracción de testigos: proceso de normalización con \textit{forma normal} buena, una demostración de un $\exists$ debería comenzar con \ruleExistsI{} y de ahí sacás el testigo.
        \proofTreeExistsI{}
    \end{itemize}
\end{frame}

% \begin{frame}{Traducción de Friedman}
%     La \textbf{traducción de Friedman} permite embeber la lógica clásica en la intuicionista, para demostraciones de \textit{algunas} fórmulas: de la clase $\classPiTwo$, de la forma \[
%         \forall \varTwo_1 \dots \forall \varTwo_n .
%         \exists \var .
%         \anyForm(\var, \varTwo_1, \dots, \varTwo_n)
%         \]
% \end{frame}

\begin{frame}{Estrategia de extracción indirecta}
    \begin{figure}
        \centering
        \includegraphics[scale=0.33]{img/arch.png}
    \end{figure}
\end{frame}

%\subsection{Traducción de Friedman}

\begin{frame}{Traducción de doble negación relativizada}
    \begin{definition}[Traducción de doble negación relativizada]
        Sea $\fNotR \form
        \equiv \form \rightarrow R$, se define la traducción de doble negación relativizada:
        \begin{align*}
            \transDNeg{\bot}                         & = \bot                                                             \\
            \transDNeg{\form}                        & = \fNotR\fNotR \form
            \quad \text{con $\form$ atómica}                                                                              \\
            \transDNeg{(\fNot \form)}                & = \fNotR \transDNeg{\form}                                          \\
            \transDNeg{(\form \fAnd \formTwo)}       & = \transDNeg{\form} \fAnd \transDNeg{\formTwo}                     \\
            \transDNeg{(\form \fOr \formTwo)}        & = \fNotR(\fNotR\transDNeg{\form} \fAnd \fNotR\transDNeg{\formTwo}) \\
            \transDNeg{(\form \rightarrow \formTwo)} & = \transDNeg{\form} \rightarrow \transDNeg{\formTwo}               \\
            \transDNeg{(\forall x . \form)}          & = \forall x . \transDNeg{\form}                                    \\
            \transDNeg{(\exists x . \form)}          & = \fNotR \forall x . \fNotR \transDNeg{\form}
        \end{align*}
    \end{definition}
    \begin{theorem}
        Si $\someProof \proves \ctx \judgC \form$, luego
        $\tdn{\someProof} \proves \tdn{\ctx} \judgI \alert<2>{\transDNeg{\form}}$
    \end{theorem}
\end{frame}

\begin{frame}{El truco de Friedman}
    \begin{definition}[Fórmulas conjuntivas]
        \[
            \cForm ::=
                \fFalse \mid \fTrue \mid \pred(\term_1, \dots, \term_n)
                \mid \cForm \fAnd \cForm
        \]
    \end{definition}

    \begin{theorem}[Traducción de Friedman]
        Sea $\anyForm$ una fórmula \textbf{conjuntiva}. Si tenemos
        \[ 
            \someProof \proves \ctx \judgC
            \forall \varTwo_1 \dots \forall \varTwo_n .
            \exists \var .
            \anyForm(\var, \varTwo_1, \dots, \varTwo_n),
        \]
        podemos generar una demostración intuicionista de la misma fórmula.
    \end{theorem}
    \pause
    \begin{lemma}[Traducción de Friedman simplificada]
        Sea $\anyForm$ una fórmula conjuntiva. Si tenemos
        \(
            \someProof \proves \ctx \judgC \exists \var . \anyForm,
        \)
        podemos generar una demostración intuicionista de la misma fórmula.
    \end{lemma}
\end{frame}
\begin{frame}{El truco de Friedman}
    \begin{proof}
        Aplicando la traducción con $R = \exists \var . \anyForm$, tenemos que
    \[
        \tdn{\big(
            \someProof \proves \ctx \judgC \exists \var . \anyForm
            \big)}
        \Leftrightarrow
        \tdn{\someProof} \proves \tdn{\ctx} \judgI \fNotR \forall \var . \fNotR \tdn{\anyForm}
    \]
    Luego, \pause
    \begin{prooftree}
        \def\defaultHypSeparation{\hskip .1in}
        \AxiomC{$\tdn{\someProof}$}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR \forall \var \fNotR \tdn{\anyForm}
            \)}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\tdn{\ctx}, \anyForm \judgI \anyForm$}
        \RL{\ruleExistsI}
        \UnaryInfC{$\tdn{\ctx}, \anyForm \judgI R = \exists \var . \anyForm$}
        \RL{\ruleImpI}
        \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \anyForm$}
        \RL{\ruleCutWith{\ruleNotRTransI}}
        \admissibleRuleLine
        \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \tdn{\anyForm}$}
        \RL{\ruleForallI}
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \forall \var \fNotR \tdn{\anyForm}
            \)}
        \RL{\ruleImpE}
        \BinaryInfC{$\tdn{\ctx} \judgI \exists \var . \anyForm$}
    \end{prooftree}
    \end{proof}
\end{frame}

\begin{frame}{Introducción de negación relativizada}
    \begin{lemma}[Introducción de $\fNotR$]
        Si $\form$ es \textit{conjuntiva}, entonces vale $\fNotR \form \judgI \fNotR \tdn{\form}$ y lo notamos con la regla admisible \ruleNotRTransI{}.
    \end{lemma}
    \pause
    \begin{proof}
        Por inducción estructural en la fórmula. Intuición:
        \begin{itemize}
            \item Atómicas trivial. Para predicados, \[\fNotR \form \judgI \fNotR \tdn{\form} \iff \fNotR \form \judgI \fNotR \fNotR \fNotR \form\] sale con \textit{eliminación de triple negación}.
            \item Conjunción tiene algunos trucos.
        \end{itemize}
    \end{proof}
\end{frame}

\begin{frame}{Traducción de demostraciones}
    \begin{theorem}
        Si $\someProof \proves \ctx \judgC \form$, luego
        $\tdn{\someProof} \proves \tdn{\ctx} \judgI \transDNeg{\form}$
    \end{theorem}
    \pause
    \begin{proof}
        Inducción estructural sobre la demostración. \textbf{Estrategia}: traducimos recursivamente las partes de $\someProof$ y las usamos para construir una nueva demostración de $\tdn{\form}$.
        \begin{itemize}
            \item \alert{\ruleAndI{}}, \ruleAndEOne{}, \ruleAndETwo{}, \ruleImpI{}, \ruleImpE{},
            \ruleOrIOne{}, \ruleOrITwo{}, \ruleForallI{}, \ruleForallE{}, \ruleNotI{}, \ruleNotE{}, \ruleTrueI{}, \ruleAx{}, \ruleExistsI{} fáciles.
            \item \alert{\ruleLEM{}} interesante.
            \item \ruleFalseE{} inducción estructural sobre la fórmula.
            \item \ruleOrE{} y \ruleExistsE{} son análogos y requieren un truco: usar la eliminación de la doble negación. No vale \ruleDnegE{} pero si \ruleDnegRE{} (probado por inducción estructural sobre la fórmula).
        \end{itemize}
    \end{proof}
\end{frame}

\begin{frame}{Traducción de introducción de conjunción}
    \begin{lemma}[Traducción de \ruleAndI{}]
        \begin{columns}
            \begin{column}{0.5\textwidth}
                \begin{prooftree}
                    \AxiomC{$\someProof_\form$}
                    \noLine
                    \UnaryInfC{$\ctx \judgI \form$}
                    \AxiomC{$\someProof_\formTwo$}
                    \noLine
                    \UnaryInfC{$\ctx \judgI \formTwo$}
                    \RL{\ruleAndI}
                    \BinaryInfC{$\ctx \judgI \form \wedge \formTwo$}
                \end{prooftree}        
            \end{column}
            \begin{column}{0.5\textwidth}
                Es posible demostrar $\tdn{(\form \fAnd \formTwo)} = \tdn{\form} \fAnd \tdn{\formTwo}$.
            \end{column}
        \end{columns}
    \end{lemma}

    \begin{proof}
        Usando la HI:
        \(
            \tdn{\someProof_\form} \proves
            \tdn{\ctx} \judgI
            \tdn{\form} \text{ y }
            \tdn{\someProof_\formTwo} \proves
            \tdn{\ctx} \judgI
            \tdn{\formTwo},
        \)
        generamos
        \begin{prooftree}
            \AxiomC{$\tdn{\someProof_\form}$}
            \noLine
            \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\form}$}
            \AxiomC{$\tdn{\someProof_\formTwo}$}
            \noLine
            \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\formTwo}$}
            \RL{\ruleAndI}
            \BinaryInfC{$\tdn{\ctx} \judgI \tdn{\form} \fAnd \tdn{\formTwo}$}
        \end{prooftree}
    \end{proof} 
\end{frame}


\begin{frame}{Problema con axiomas}
    \begin{lemma}[Traducción de Friedman simplificada]
        Sea $\anyForm$ una fórmula conjuntiva. Si tenemos
        \(
            \ctx \judgC \exists \var . \anyForm,
        \)
        podemos generar una demostración intuicionista de la misma fórmula
        \(
            \alert{\tdn{\ctx}} \judgI \exists \var . \anyForm.
        \)
    \end{lemma}
    
    \textbf{Problema:} la demostración normalizada no puede comenzar con \ruleExistsI{}
    \[
        \tdn{\pred(v)} \judgI \exists \var . \pred(\var)
        \iff
        \fNotR \fNotR \pred(v) \judgI \exists \var . \pred(\var)
    \]
    Nos gustaría \textit{mantener el contexto original}:
    \(
        p(v) \judgI \exists \var . \pred(\var)
    \)
    \begin{block}{Manteniendo el contexto}
        Luego de la traducción, antes de reducir, reemplazamos cada cita (\ruleAx) de un axioma $\hypId: \tdn{\anyForm}$ por la demostración $\anyForm \judgI \tdn{\anyForm}$.
    \end{block}
    \begin{lemma}[Introducción de la traducción $\fNot\fNot$]
        Si $\anyForm$ es una \textit{F-fórmula}, vale
        $\anyForm \judgI \tdn{\anyForm}$.
    \end{lemma}

\end{frame}

\begin{frame}{F-fórmulas}
    \vspace{-0.2cm}
    \begin{columns}[t]
        \begin{column}{0.4\textwidth}
            \begin{block}{F-fórmulas}
                \vspace{-0.4cm}
                \begin{align*}
                    \form ::=\ & \fFalse \mid \fTrue \mid \pred(\term_1, \dots, \term_n)\\
                    \fForm ::=\  &\form \\
                    & \mid \fForm \fAnd \fForm \mid \fForm \fOr \fForm                       \\
                    & \mid \forall \var . \fForm \mid \exists \var . \fForm                      \\
                    & \mid \cForm \fImp \fForm                                                     \mid \fNot \cForm\\
                    \cForm ::=\ & A  \mid \cForm \fAnd \cForm
                \end{align*}
            \end{block}
            \begin{itemize}
                \item $A$: Fórmulas atómicas
                \item $F$: F-fórmulas
                \item $C$: Fórmulas conjuntivas
            \end{itemize}
        \end{column}
        \pause
        \begin{column}{0.5\textwidth}
            \begin{block}{Fórmulas de Harrop}
                \vspace{-0.4cm}
                \begin{align*}
                    G ::=\ & \form\\
                        &\mid G \fAnd G \mid G \fOr G \\
                        &\mid \forall x . G \mid \exists x. G \\
                        &\mid H \fImp G\\
                    H ::=\ & A \mid H \fAnd H                    \\
                            & \alert<2>{\mid \forall \var . H}\\
                            & \alert<2>{\mid G \fImp A}
                \end{align*}            
            \end{block}
            \begin{itemize}
                \item $G$: G-fórmulas
                \item $H$: Fórmulas Harrop Hereditarias
                \item Generalización de cláusulas de Horn, usadas para realizabilidad
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

% \begin{frame}{Repaso - estrategia de extracción indirecta}
%     \begin{figure}
%         \centering
%         \includegraphics[scale=0.33]{img/arch.png}
%     \end{figure}
% \end{frame}


\begin{frame}{Normalización}
    \textbf{Motivación}: evitar \textit{``desvíos superfluos''}.

    \begin{example}
        \[
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{$\form \judG \form$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judG \form \fImp \form$}
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{$\formTwo \judG \formTwo$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judG \formTwo \fImp \formTwo$}
    \RL{\alert<2>{\ruleAndI}}
    \BinaryInfC{$\judG (\form \fImp \form) \fAnd (\formTwo \fImp \formTwo)$}
    \RL{\alert<2>{\ruleAndEOne{}}}
    \UnaryInfC{$\judG \form \fImp \form$}
\DisplayProof
\quad
\rewrite
\quad
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{$\form \judG \form$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judG \form \fImp \form$}
    \DisplayProof
\]
    \end{example}

    \pause
    \begin{itemize}
        \item Se van a ver todos de esa forma: Una \textbf{eliminación} demostrada inmediatamente por su \textbf{introducción} correspondiente. 
        \item Ejemplo: \ruleAndEOne{} demostrada por \ruleAndI{}.
        \item Idea: Simplificarlos sucesivamente hasta que no haya más y esté en \textbf{forma normal}.
    \end{itemize}
\end{frame}

\begin{frame}{Curry Howard}
    \begin{itemize}
        \item \textbf{Isomorfismo Curry-Howard}: correspondencia entre demostraciones en deducción natural y términos de $\lambda$-cálculo.
        \item Normalización de demostraciones corresponde a semántica de $\lambda$-cálculo
    \end{itemize}

    \begin{example}
        Conjunciones como el tipo de las tuplas, y las eliminaciones como proyecciones.
        \begin{align*}
            \projectOne{\tuple{\lTerm_1}{\lTerm_2}} &\rewrite \lTerm_1\\
            \projectTwo{\tuple{\lTerm_1}{\lTerm_2}} &\rewrite \lTerm_2
        \end{align*}
        \[
            \reductionAnd
        \]
    \end{example}
\end{frame}

\begin{frame}{Normalización de implicación}
    \[
        \AxiomC{$\someProof_\formTwo$}
    \noLine
    \UnaryInfC{$\ctx, \hypId: \form \judG \formTwo$}
    \RL{\ruleImpIh{\hypId}}
    \UnaryInfC{$\ctx \judG \form \fImp \formTwo$}
    \AxiomC{$\someProof_\form$}
    \noLine
    \UnaryInfC{$\ctx \judG \form$}
    \RL{\ruleImpE}
    \BinaryInfC{$\ctx \judG \formTwo$}
    \DisplayProof
    %
    \quad \rewrite \quad
    %
    \AxiomC{$\someProof_\formTwo\only<2->{\alert{\subst{\hypId}{\someProof_\form}}}$}
    \noLine
    \UnaryInfC{$\ctx \judG \formTwo$}
    \DisplayProof
    \]

    \begin{itemize}
        \item Primer idea: \xxcancel<2->{$\someProof_\formTwo \proves \ctx \judG \formTwo$} \pause
        \item $\someProof_\formTwo$ requiere $\hypId : \form$, agregada por \ruleImpIh{\hypId}
        \item Correcto: usar $\someProof_\formTwo$, pero \textit{sustituyendo} todas las ocurrencias de la hipótesis $\hypId$ por la demostración $\someProof_\form$ (sin capturas).
    \end{itemize}
\end{frame}

\begin{frame}{Reglas de reducción}
    Además, hay reglas para
    \begin{itemize}
        \item \ruleExistsE{} con \ruleExistsI{},
        \item \ruleForallE{} con \ruleForallI{},
        \item \ruleNotE{} con \ruleNotI{},
        \item \ruleOrE{} con \ruleOrI{}
    \end{itemize}
\end{frame}

\begin{frame}{Algoritmo de reducción}
    \textbf{Idea original}: reducir en un paso sucesivamente hasta que sea irreducible.


\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form}$}
    \AxiomC{$\judg{\ctx}{\formTwo}$}
    \RL{\ruleAndI}
    \BinaryInfC{$\judg{\ctx}{\form \wedge \formTwo}$}
    \noLine
    \UnaryInfC{$\vdots$}
    \noLine
    \UnaryInfC{$\someProof$}
\end{prooftree}

reducíamos de a un paso a la vez $\form \rewrite \form_1 \rewrite \form_2
\rewrite \dots \rewrite \form^{*}$ hasta llegar a $\form^{*}$ irreducible y
recién ahí aplicamos mismo para $\formTwo$. En cada paso se recorría todo el árbol.

Problema: Muy lento
\end{frame}

\begin{frame}{Estrategia de reducción}
    Dos tipos de estrategias:
    \begin{itemize}
        \item Un paso
        \item Muchos pasos
        \begin{itemize}
            \item \textbf{Gross Knuth}: reduce en muchos pasos todos los sub-términos posibles al mismo tiempo.
        \end{itemize}
    \end{itemize}

    En un solo paso, reducimos

    \[
        \AxiomC{$\judg{\ctx}{\form}$}
        \AxiomC{$\judg{\ctx}{\formTwo}$}
        \RL{\ruleAndI}
        \BinaryInfC{$\judg{\ctx}{\form \wedge \formTwo}$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$\someProof$}
        \DisplayProof
        \quad
        \rewrite
        \quad
        \AxiomC{$\judg{\ctx}{\alert{\form^{*}}}$}
        \AxiomC{$\judg{\ctx}{\alert{\formTwo^{*}}}$}
        \RL{\ruleAndI}
        \BinaryInfC{$\judg{\ctx}{\form \wedge \formTwo}$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$\someProof$}
        \DisplayProof
    \]
\end{frame}

\begin{frame}{Limitaciones}
    \begin{itemize}[<+->]
        \item \textbf{Incompleta}: no contempla \textit{reducciones permutativas} (mezclando introducciones y eliminaciones de conectivos distintos).
        \begin{itemize}
            \item \textit{Mejora}: Implementarlas.
        \end{itemize}
        \item \textbf{Ineficiente}: en cada paso reinicia la búsqueda de todos los focos de evaluación.
        \begin{itemize}
            \item \textit{Mejora}: Usar una máquina abstracta que implemente reducción a forma normal, Crégut para reducción \textit{call-by-name} fuerte o la máquina de Biernacka para reducción \textit{call-by-need} fuerte.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Programa con falla de extracción}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \lstinputlisting{listings/ppt/extract/or-fail.ppa}
        \end{column}
        \begin{column}{0.5\textwidth}
            Certifica el programa generando una demostración que en lugar de comenzar con \ruleExistsI{}, comienza con \ruleOrE{} y en cada rama introduce el existencial dos veces, con el mismo término
        \end{column}
        
    \end{columns}
\end{frame}

% \begin{frame}{Mecanismo de extracción de testigos}
%     \begin{itemize}
%         \item 
%     \end{itemize}
% \end{frame}

% \begin{frame}{Dificultades}
%     \begin{itemize}
%         \item \textit{Integration hell}
%         \item Encontré poca bibliografía de Friedman. Ni hablar que hable de  generación de demostraciones en deducción natural.
%     \end{itemize}
% \end{frame}

\section{Detalles de implementación}

\begin{frame}{La herramienta \ppaTool{}}
    \begin{figure}
        \includegraphics[scale=0.285]{img/modules.png}
        \centering
        \small Haskell, 19 módulos con 330 tests
    \end{figure}
    % Aprovechar para hacer un repaso
\end{frame}

\begin{frame}{Parser y lexer}
    \begin{figure}
        \includegraphics[scale=0.28]{img/ppt/parsers.png}
    \end{figure}
\end{frame}


\section{Trabajo futuro}

\begin{frame}{Trabajo futuro}    
    \begin{itemize}[<+->]
        \item Sofisticar el \textit{solver heurístico} del \lstinline{by} (recursivo, eliminar más de una hipótesis).
        \item Extender traducción de Friedman a más de un existencial.
        \item Refinar fórmulas conjuntivas. Profundizar vínculo con Harrop.
        \item Sofisticar reducción de demostraciones: hacer completa (reglas permutativas) y más eficiente (implementando máquina abstracta).
        \item Mejorar \ppaLang{} como lenguaje de programación: módulos, importar archivos, biblioteca estándar.
        \item Extender PPA con tipos (usando LPO \textit{many-sorted} con géneros).
        \item Modelar de forma nativa inducción (segundo orden) e igualdad.
        \item Mejorar reporte de errores (muy bajo nivel).
    \end{itemize}
\end{frame}

\begin{frame}{Fin}
    \begin{itemize}
        \item QR con la página
        \item Preguntas
    \end{itemize}
\end{frame}

\end{document}