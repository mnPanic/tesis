En el \fullref{chap:ppa} vimos a \ppaLang{} como un lenguaje, desde el punto de
vista de un usuario. En \fullref{chap:ppa-certifier} abordamos el funcionamiento
interno, que expandimos en \fullref{chap:witness-extraction} con extracción de
testigos. En este capítulo presentamos la herramienta de línea de comandos
\ppaTool{}, que permite procesar programas del lenguaje. Está implementada en Haskell.

\section{Instalación}

Para instalar \ppaTool{} a partir de los fuentes, seguir los siguientes pasos.

\begin{enumerate}
    \item Instalar \href{https://www.haskell.org/}{Haskell}, \href{https://www.haskell.org/cabal/}{Cabal}
    \item Clonar el repositorio de \ppaTool{} o descargarlo \url{https://github.com/mnPanic/tesis}
    \item Instalar la herramienta con cabal
    \begin{minted}{bash}
tesis/ppa:~$ cabal install ppa
    \end{minted}
    \item Verificar la instalación
    \begin{minted}{bash}
tesis/ppa:~$ ppa version
ppa version 0.1.0.0
    \end{minted}
\end{enumerate}

\section{Interfaz y ejemplos}

El ejecutable \ppaTool{} cuenta con dos comandos: \texttt{check} (certificado y
chequeo de programas) y \texttt{extract} (extracción de testigos). En el
repositorio de los fuentes, el directorio \texttt{ppa/doc/examples} contiene
ejemplos de programas. La extensión por convención de programas de \ppaTool{} es \texttt{.ppa}.

\subsection{\texttt{check} - Chequeo de programas}

Permite certificar y chequear programas.

\begin{minted}{bash}
ppa check <in> <args>
\end{minted}

Argumentos:

\begin{itemize}
    \item El primer argumento posicional es el archivo que contiene el programa
    a certificar. Puede ser \texttt{-} para leer de \textit{stdin}.
    \item \texttt{--out}, \texttt{-o} (\textit{opcional}): Path para el archivo
    al cual escribir el certificado (con el sufijo \texttt{\_raw.nk}) o
    \texttt{-} para usar \textit{stdout}.
\end{itemize}


Primero lee, certifica y chequea el programa reportando el resultado. En caso de
haber proporcionado un archivo de output, escribe el certificado de deducción
natural a \texttt{<path>\_raw.nk}.

Ejemplos:

\begin{minted}{bash}
$ ppa check doc/examples/parientes.ppa
Checking... OK!
\end{minted}

\begin{minted}{bash}
$ ppa check doc/examples/parientes.ppa --out out   
Checking... OK!
Writing...
Wrote raw to out_raw.nk
\end{minted}

\subsection{\texttt{extract} - Extracción de testigos}

Permite ejecutar la extracción de testigos.

\begin{minted}{bash}
ppa extract <in> <args>
\end{minted}

Argumentos:

\begin{itemize}
    \item El primer argumento posicional es el archivo de entrada que contiene
    el programa. Puede ser \texttt{-} para leer de \textit{stdin}.
    \item \texttt{--theorem}, \texttt{-t} (\textit{obligatorio}): el nombre del
    teorema para el cual extraer el testigo
    \item \texttt{--terms}, \texttt{ts}: la lista de términos que indica cómo
    instanciar las variables cuantificadas universalmente. Debe contener la
    misma cantidad de términos que variables.
    \item \texttt{--out}, \texttt{-o} (\textit{opcional}): Path para el archivo
    al cual escribir los certificados (con los sufijos \texttt{\_raw.nk} y
    \texttt{.nj}) o \texttt{-} para usar \textit{stdout}.
\end{itemize}

Primero lee y certifica, y chequea el programa. Luego, lo traduce con la
traducción de Friedman, normaliza la demostración e intenta extraer un testigo,
reportando cual fue el testigo extraído y cómo queda el término final con el
testigo y los términos proporcionados para instanciar las variables
cuantificadas universalmente.

Por ejemplo, si tenemos el programa de \namedref{fri:prog:forall}

\begin{minted}{bash}
$ ppa extract doc/listings/extract/forall.ppa --theorem t --terms x
Running program... OK!
Translating... OK!
Checking translated... OK!
Extracted witness: v
of formula: p(x, v)
\end{minted}

Y especificando output,

\begin{minted}{bash}
$ ppa extract doc/listings/extract/forall.ppa --theorem t --terms x -o out
Running program... OK!
Translating... OK!
Writing...
Wrote raw to out_raw.nk
Wrote translated+reduced to out.nj
Checking translated... OK!
Extracted witness: v
of formula: p(x, v) 
\end{minted}

\section{Detalles de implementación}

En esta sección contamos algunos detalles relevantes sobre la implementación,
que deberían permitir navegar los fuentes para ver cómo fue implementado.
Comencemos por la arquitectura de los módulos.

\subsection{Parser y Lexer}

Una parte esencial de \ppaTool{} es el compilador, que tiene dos etapas que
permiten interpretar un programa desde un archivo de texto hacia una
representación de un tipo abstracto de datos que puede ser manipulado.

Para el parsing teníamos dos opciones. O bien hacerlo a mano con alguna
biblioteca de \textit{parser combinators} como
\href{https://hackage.haskell.org/package/parsec}{parsec}, o usar un
\textit{parser generator}: un programa que genere un parser automáticamente a
partir de una gramática en algún formato como EBNF. Nosotros decidimos, por
familiaridad con el proceso, usar un parser generator. Los más conocidos
históricamente son Lex (para el lexer) y Yacc (para el parser, \textit{yet
another compiler compiler}). En Haskell existen versiones análogas

\begin{figure}[H]
\begin{multicols}{2}
\begin{minted}{haskell}
type VarId = String
type FunId = String
type PredId = String
type HypId = String

data Term
    = TVar VarId
    | TMetavar Metavar
    | TFun FunId [Term]

data Form
    = FPred PredId [Term]
    | FAnd Form Form
    | FOr Form Form
    | FImp Form Form
    | FNot Form
    | FTrue
    | FFalse
    | FForall VarId Form
    | FExists VarId Form
\end{minted}
\end{multicols}
\caption{Modelado de fórmulas y términos de LPO}
\end{figure}

Las meta-variables se usan para unificación, que es parte del solver de PPA. Ver
más en \fullref{ppa:sec:by:forall-elim}

\begin{figure}[H]
    
\begin{multicols}{2}
\begin{minted}{haskell}
data Proof =
    | PAx HypId
    | PAndI
        { proofLeft :: Proof
        , proofRight :: Proof
        }
    | PAndE1
        { right :: Form
        , proofAnd :: Proof
        }
    | PAndE2
        { left :: Form
        , proofAnd :: Proof
        }
    | POrI1
        { proofLeft :: Proof
        }
    | POrI2
        { proofRight :: Proof
        }
    | POrE
        { left :: Form
        , right :: Form
        , proofOr :: Proof
        , hypLeft :: HypId
        , proofAssumingLeft :: Proof
        , hypRight :: HypId
        , proofAssumingRight :: Proof
        }
    | PImpI
        { hypAntecedent :: HypId
        , proofConsequent :: Proof
        }
    | PImpE
        { antecedent :: Form
        , proofImp :: Proof
        , proofAntecedent :: Proof
        }
    | PNotI
        { hyp :: HypId
        , proofBot :: Proof
        }
    | PNotE
        { form :: Form
        , proofNotForm :: Proof
        , proofForm :: Proof
        }
    | PTrueI
    | PFalseE
        { proofBot :: Proof
        }
    | PLEM
    | PForallI
        { newVar :: VarId
        , proofForm :: Proof
        }
    | PForallE
        { var :: VarId
        , form :: Form
        , proofForall :: Proof
        , termReplace :: Term
        }
    | PExistsI
        { inst :: Term
        , proofFormWithInst :: Proof
        }
    | PExistsE
        { var :: VarId
        , form :: Form
        , proofExists :: Proof
        , hyp :: HypId
        , proofAssuming :: Proof
        }
\end{minted}        
\end{multicols}
\caption{Modelado de reglas de inferencia para demostraciones}
\end{figure}


El modelado de las reglas de inferencia omite varios detalles que están
implícitos y serán inferidos por el algoritmo de chequeo. De esa forma las
demostraciones son más fáciles de escribir y generar. Por ejemplo,
\texttt{PImpI} no especifica en su modelo cuál es la implicación que se está
introduciendo, dado que durante el chequeo debería ser la fórmula actual a
demostrar

\section{Compiladores}
\begin{itemize}
    \item Primer de compiladores en general y sus frontends
    \item Parser generators en general. LR/LALR
    \item Happy. Alex.
    \item Sintaxis BNF en apéndice (el archivo). Incluir el archivo Alex/happy? Es cortito
\end{itemize}