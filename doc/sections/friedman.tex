% Puntos a abordar

% - mencionar realizabilidad clásica. Related work capaz en la conclusión
% - hacer una investigación de otras formas de hacer witness extraction. Capaz no es original lo nuestro (y capaz Coq lo banca con realizabilidad).

% \begin{itemize}
%     \item Motivación, limitaciones de lógica clásica. Demostración sqrt 2
%     \item Lógica intuicionista
%     \item Como necesitamos reducir en ND, necesitamos la demo en ND. Escribirla
%           en este caso.
%     \item También queremos para $\classPiTwo$, mostrar la extensión en ND.
%     \item En realidad no nos sirve $\transDNeg{\Gamma}$, queremos dejarlo como
%           está y demostrar que los axiomas demuestran sus traducciones. Pero no vale
%           siempre (buscar c.ej), caracterizar cuando.
%     \item Sumarizar cómo queda, vincular con reducción. Mostrar ejemplos en PPA
%           que funcionan y ejemplos que no.
%     \item Extensión a demostraciones. Mostrar algunos ejemplos interesantes (y
%           los que usen los lemas dNegRElim y rElim)
%     \item Lemas para demostraciones: dNegRElim (relacionar con \ref{ppa-cert:sec:abs-reasoning}), rElim, tNegRElim
%     \item Reducción (buena explicación
%           \url{https://plato.stanford.edu/entries/natural-deduction/}). En realidad se
%           conoce como \textbf{normalization}.
%           \begin{itemize}
%               \item Similitud con reducción en cálculo lambda.
%               \item Ejemplos de LP y todo LPO
%               \item substHyp, substVar en proofs
%               \item Argumentos de que es correcto y completo?
%               \item Small step vs big step
%           \end{itemize}
% \end{itemize}

\newpage

En los capítulos anteriores vimos como el lenguaje PPA puede ser usado para
escribir demostraciones de alto nivel, que son certificadas generando
demostraciones de bajo nivel usando el sistema lógico de deducción natural.
Ahora vamos a introducir una nueva funcionalidad: la \textbf{extracción de testigos}.

\begin{multicols}{2}
    \begin{figure}[H]
        \lstinputlisting{listings/extract/exists.ppa}
        \caption{Extracción simple}
        \label{fri:prog:exists}
    \end{figure}

    \begin{figure}[H]
        \lstinputlisting{listings/extract/forall.ppa}
        \caption{Extracción con instanciación}
        \label{fri:prog:forall}
    \end{figure}
    \begin{figure}[H]
        \lstinputlisting[firstline=2]{listings/extract/indirect.ppa}
        \caption{Extracción indirecta}
        \label{fri:prog:indirect}
    \end{figure}
\end{multicols}

Por ejemplo, en el programa \fullref{fri:prog:exists} la extracción nos
permitirá encontrar un término $t$ que sea \textit{testigo} de $\exists x. p(x)$: que cumpla $p(t)$. En este caso es fácil encontrarlo a ojo sobre la
demostración de PPA, sería \lstinline{v}. Pero puede haber casos en donde no sea
tan trivial, como en el programa \fullref{fri:prog:indirect}, en donde en el
\lstinline{theorem t2} se instancia la variable en un término de forma
indirecta. Además, también querríamos poder extraer en casos donde haya
cuantificadores universales, como en \fullref{fri:prog:forall}. Aquí, ya que vale para todo \lstinline{Y}, querremos poder instanciarlo en un término cualquiera. Por ejemplo \lstinline{p(v, f(v))}.

Buscamos un mecanismo general, que nos permita a partir de cualquier
demostración una fórmula de la forma $\forall \var_0 \dots \forall \var_n
\exists \varTwo . \anyForm(\var_0, \dots, \var_n, \varTwo)$ extraer un testigo $\termTwo$ tal que, para $\term_0, \dots, \term_n$ cuales quiera, valga $\anyForm(\term_0, \dots, \term_n, \termTwo)$. Vamos a hacerlo a partir
de los certificados de deducción natural.

\section{La lógica clásica no es constructiva}

El objetivo es extraer el testigo de las demostraciones generadas por el
certificador, pero estas son en lógica clásica, que tiene el gran problema de
que en general \textbf{no es constructiva}. ¿Qué quiere decir? Puede suceder que
una demostración de $\exists x . p(x)$ no diga explícitamente quien es $x$, y
por lo tanto no podamos extraer un testigo. Esto sucede porque vale el \textit{principio del tercero excluido} o LEM

\begin{prop}[LEM] Para toda fórmula $\form$, es verdadera ella o su negación
    \[ \form \fOr \fNot \form \]
\end{prop}

Las demostraciones que usan este principio suelen dejar aspectos sin
concretizar, como muestra el siguiente ejemplo bien conocido:

\begin{theorem}\label{fri:thm:irrat}
    Existen dos números irracionales $a$ y $b$ tales que $a^b$ es irracional
\end{theorem}
\begin{proof}
    Considerar el número $\sqrt{2}^{\sqrt{2}}$. Por LEM, es o bien racional o
    irracional.
    \begin{itemize}
        \item Supongamos que es racional. Como sabemos que $\sqrt{2}$ es
              irracional, podemos tomar $a=b=\sqrt{2}$ que por hipótesis es racional.
        \item Supongamos que es irracional. Tomamos $a = \sqrt{2}^{\sqrt{2}}, b
                  = \sqrt{2}$. Ambos son irracionales, y tenemos

              \[
                  a^b
                  = \left( \sqrt{2}^{\sqrt{2}} \right)^{\sqrt{2}}
                  = \sqrt{2}^{\sqrt{2} \cdot \sqrt{2}}
                  = \sqrt{2}^{2}
                  = 2,
              \]

              que es racional.
    \end{itemize}

    En ambos casos podemos encontrar $a, b$ tales que $a^b$ es racional. $\therefore$ existen.
\end{proof}

La prueba no nos da forma de saber cuales son $a$ y $b$. Es por eso que en
general, en lógica clásica, tener una demostración de un teorema que afirma la
existencia de un objeto que cumpla cierta propiedad, no necesariamente nos da
una forma de encontrarlo. De esta demostración nunca podríamos extraer un testigo. Pero se podría haber demostrado de otra manera que sí sea constructiva, y omita el uso de \ruleLEM{}. En particular tomando $a = \sqrt{2}$ y $b = 2 \log_2{3}$ (ver \cite{andrej-constructive}) ¿Es este el caso con todas las demostraciones?

\begin{ejemplo}[Fórmula sin demostración constructiva]
    Si consideramos la fórmula
    \[
        \exists x . ((x = 1 \fAnd C) \fOr (x = 0 \fAnd \fNot C))
    \]
    y pensamos en $C$ como algo indecidible, por ejemplo \texttt{HALT},
    trivialmente podemos demostrarlo de forma no constructiva (LEM con $C \fOr
        \fNot C$) pero \textbf{nunca} de forma constructiva.
\end{ejemplo}

\section{Lógica intuicionista}

Como alternativa a la lógica clásica existe existe la lógica
\textbf{intuicionista}, que se puede definir como la lógica clásica sin
LEM\footnote{Al no tener LEM, tampoco valen principios de razonamiento clásicos
equivalentes, como la eliminación de la doble negación.}. Al no valer ese
principio, las demostraciones siempre son constructivas. Esto permite por un
lado tener interpretaciones computacionales (como la \textit{BHK}) y además que
exista la noción de \textit{forma normal} de una demostración. Existen métodos
bien conocidos para reducir pruebas hacia su forma normal con un proceso análogo
a una reducción de cálculo $\lambda$. Vemos esto más en detalle en la \fullref{fri:sec:reduction}.

Esto permite usar como estrategia de extracción la siguiente: normalizar la
demostración y obtener el testigo de la forma normal. En ella, se esperaría que
toda demostración de un $\exists$ sea mediante \ruleExistsI{}, explicitando el
testigo.

\section{Estrategia de extracción de testigos}

Queremos extraer testigos de las demostraciones generadas por el certificador de
PPA, pero son en lógica clásica. Sabemos que podemos hacerlo para lógica
intuicionista. ¿Cómo conciliamos ambos mundos? Existen métodos que permiten
\textit{embeber} la lógica clásica en la intuicionista. Uno de ellos es la
\textbf{traducción de Friedman} que se aborda en la siguiente sección (\ref{fri:sec:fri}). La
estrategia general entonces es la siguiente (esquematizada en la \namedref{fri:fig:strat}), dado un programa en PPA como
por ejemplo de \namedref{fri:prog:exists}:
\begin{enumerate}
    \item La certificamos generando una demostración clásica en deducción
          natural, usando el \modCertifier{}. Nos da un contexto con una demostración
          por teorema.

          \textbf{Limitación}: No vamos a poder axiomatizar cualquier teoría.
    \item Queremos extraer un testigo de un teorema, que puede citar a los anteriores. Generamos una única demostración haciendo \textit{inline} de las demostraciones de otros teoremas citados, así cuando se reduce, se reduce la demostración completa y no una parte.
    \item Usamos la traducción de Friedman para obtener una demostración
          intuicionista de la misma fórmula.

          \textbf{Restricción}: La fórmula a demostrar debe ser de la forma
          $\forall \varTwo_0 \dots \forall \varTwo_n . \exists \var . \anyForm$.
    \item Instanciamos las variables de los $\forall$ en términos proporcionados
          por el usuario, quedando una fórmula de la forma $\exists \var . \form$.
    \item Normalizamos la demostración.

          \textbf{Limitación}: No vamos a poder llevar cualquier demostración a
          su forma normal.

    \item Al ser una demostración normalizada de un $\exists$, debe comenzar con
          \ruleExistsI{}, que especifica el término que hace cierta la fórmula. Este
          es precisamente el testigo que estábamos buscando.
          \proofTreeExistsI
\end{enumerate}

En las siguientes secciones vemos en detalle la traducción de Friedman
(\namedref{fri:sec:fri}) y la normalización (o reducción) de demostraciones (\namedref{fri:sec:reduction}). Al final vemos un detalle técnico de la traducción, necesario para permitir la reducción, que limita la forma de los axiomas (\namedref{fri:sec:context}).

\begin{figure}
    \includegraphics[scale=0.35]{img/fri-extract-strategy.png}
    \centering
    \caption{Estrategia de extracción de testigos}
    \label{fri:fig:strat}
\end{figure}

\section{Traducción de Friedman}
\label{fri:sec:fri}

Existen muchos métodos que permiten embeber la lógica clásica en la
intuicionista. Un mecanismo general es la traducción de
\textbf{doble negación}, que tiene distintas variaciones. Una es la
\textit{Gödel-Gentzen} \cite{Avigad1998-FEFOFD}

\begin{definition}[Traducción \textit{Gödel-Gentzen}] Dada una fórmula $\form$
    se asocia con otra $\gN{\form}$. La traducción se define por inducción
    estructural.
    \begin{align*}
        \gN{\fFalse}                      & = \fFalse                                           \\
        \gN{\fTrue}                       & = \fTrue                                            \\
        \gN{\form}                        & = \fNot\fNot \form \quad \text{con $\form$ atómica} \\
        \gN{(\form \fAnd \formTwo)}       & = \gN{\form} \fAnd \gN{\formTwo}                    \\
        \gN{(\form \fOr \formTwo)}        & = \fNot(\fNot\gN{\form} \fAnd \fNot\gN{\formTwo})   \\
        \gN{(\form \fImp \formTwo)}       & = \gN{\form} \fImp \gN{\formTwo}                    \\
        \gN{(\forall \var . \form(\var))} & = \forall \var . \gN{\form(\var)}                   \\
        \gN{(\exists \var . \form(\var))} & = \fNot \forall \var . \fNot \gN{\form(\var)}
    \end{align*}
\end{definition}


\begin{definition}[Traducción de contextos]
    Se extiende a contextos de la forma esperable
    \[
        \gN{\ctx} = \{\gN{\form} \mid \form \in \ctx \}.
    \]
\end{definition}

\begin{notation*}
    Notamos,
    \begin{itemize}
        \item $\judgC$ para expresar que un juicio es derivable en lógica clásica,
              y $\judgI$ para intuicionista.
        \item $\someProof \proves \ctx \judG \form$ para expresar que $\someProof$ es una demostración de $\ctx \judG \form$. Equivalente a
              \AxiomC{$\someProof$}
              \noLine
              \UnaryInfC{$\ctx \judG \form$}
              \DisplayProof
    \end{itemize}
\end{notation*}

\begin{theorem}
    Si tenemos $\ctx \judgC \form$, luego $\gN{\ctx} \judgI \gN{\form}$.
\end{theorem}

Dada una demostración en lógica clásica, podemos obtener una en lógica
intuicionista de su traducción. Pero esto no es exactamente lo que queremos,
pues si quisiéramos extraer un testigo de una demostración de la fórmula
$\exists \var. \pred(\var)$, al traducirla nos quedaría
\(
\gN{(\exists \var. \pred(\var))}
= \fNot \forall \var . \fNot\fNot\fNot \pred(\var)
\).
Si bien su demostración será intuicionista (y por lo tanto constructiva),
como no es de un $\exists$ al normalizarla no podremos hacer la extracción.

\subsection{El truco de Friedman}

La idea de Friedman \cite{miquel-friedman} es generalizar la traducción
Gödel-Gentzen reemplazando la negación intuicionista $\fNot \form \equiv A
\rightarrow \bot$ por una \textit{relativa} $\fNotR \form \equiv \form
\rightarrow R$ parametrizada por una fórmula arbitraria $R$. Esto nos va a
permitir, con una elección inteligente de $R$, traducir una demostración clásica
de una fórmula a una intuicionista, y usarla para generar una demostración de
\textbf{la fórmula original}. Esto nos permite reducirla y hacer la extracción.
No va a ser posible para cualquier fórmula, sino las de una clase particular que definimos más adelante (de
la forma $\forall \varTwo_1 \dots \forall \varTwo_m . \exists \var_1 \dots
\exists \var_k . \anyForm$).

\begin{definition}[Traducción de doble negación relativizada]
    \begin{align*}
        \transDNeg{\bot}                         & = \bot                                                             \\
        \transDNeg{\form}                        & = \fNotR\fNotR \form
        \quad \text{con $\form$ atómica}                                                                              \\
        \transDNeg{(\fNot \form)}                & = \fNotR \transDNeg{\form}                                          \\
        \transDNeg{(\form \fAnd \formTwo)}       & = \transDNeg{\form} \fAnd \transDNeg{\formTwo}                     \\
        \transDNeg{(\form \fOr \formTwo)}        & = \fNotR(\fNotR\transDNeg{\form} \fAnd \fNotR\transDNeg{\formTwo}) \\
        \transDNeg{(\form \rightarrow \formTwo)} & = \transDNeg{\form} \rightarrow \transDNeg{\formTwo}               \\
        \transDNeg{(\forall x . \form)}          & = \forall x . \transDNeg{\form}                                    \\
        \transDNeg{(\exists x . \form)}          & = \fNotR \forall x . \fNotR \transDNeg{\form}
    \end{align*}
\end{definition}

\begin{theorem}
    \label{fri:thm:dneg-trans-classic-int}
    Si $\ctx \judgC \form$, luego $\transDNeg{\ctx} \judgI \transDNeg{\form}$
\end{theorem}
\begin{proof}
    Dada una demostración en deducción natural clásica $\ctx \judgC \form$, podemos traducirla recursivamente extendiendo la traducción de fórmulas a reglas de inferencia, así generando una demostración de $\transDNeg{\ctx} \judgI \transDNeg{\form}$.
    Este proceso está descrito en detalle en \fullref{fri:sec:proof-trans}
\end{proof}

Vamos a enunciar diferentes versiones de la traducción de Friedman en orden de sofisticación, según para qué clase de fórmulas funcionan. No solo ayuda a entenderla, sino que también fue el mismo enfoque con el que las implementamos. Cada una incluye a la anterior, por lo que en \ppaTool{} solo quedó implementada la última. Todas emplean la misma estrategia. Usando el \namedref{fri:thm:dneg-trans-classic-int}, se traduce la demostración clásica a una intuicionista para la fórmula traducida, que se usa para probar la fórmula original.


\begin{definition}[Jerarquía aritmética de fórmulas]
    Clasifica las fórmulas en dos clases: $\classPi{n}$ y
    $\classSigma{n}$. Se define por inducción en $n$.

    \begin{itemize}
        \item Si $\anyForm$ es equivalente a una fórmula sin cuantificadores, está en
              $\classPi{0}$ y $\classSigma{0}$.
        \item Sean las clasificaciones $\classPi{n}$ y $\classSigma{n}$. Definimos para $n+1$.
              \begin{itemize}
                  \item Si $\anyForm$ es equivalente a una formula de la forma $\exists
                            \var_1 \dots \exists \var_k. \anyFormTwo$ donde $\anyFormTwo$ es
                        $\classPi{n}$, entonces $\anyForm$ es asignada la clasificación $\classSigma{n+1}$.

                  \item Si $\anyForm$ es equivalente a una formula de la forma $\forall
                            \var_1 \dots \forall \var_k. \anyFormTwo$ donde $\anyFormTwo$ es
                        $\classSigma{n}$, entonces $\anyForm$ es asignada la clasificación $\classPi{n+1}$.
              \end{itemize}
    \end{itemize}

    Una fórmula de $\classSigma{n}$ es equivalente a una que comienza con
    cuantificadores existenciales y alterna $n-1$ veces entre series de
    universales y existenciales. Mientras que una $\classPi{n}$ es análoga pero
    comenzando con universales. Las dos relevantes son:
    \begin{itemize}
        \item $\classSigmaOne$: fórmulas de la forma $\exists \var_1 \dots
                  \exists \var_k . \anyForm$.
        \item $\classPiTwo$: fórmulas de la forma $\forall \varTwo_1 \dots \forall \varTwo_m . \exists \var_1 \dots \exists \var_k . \anyForm$
    \end{itemize}
\end{definition}
\begin{obs*}[Intuición detrás de $\Sigma$ y $\Pi$]
    Una intuición detrás de los nombres de las clases puede ser
    \begin{itemize}
        \item $\Sigma$ es una sumatoria, que se puede interpretar como
              disyunciones (en el sentido del álgebra de Boole), y generalizar con un existencial.
        \item $\Pi$ análogamente pero con productoria, conjunciones y universales.
    \end{itemize}
\end{obs*}

\subsection{Versiones de la traducción}

Podremos probar una fórmula en lógica intuicionista a partir de una demostración clásica solo si está en alguna de estas clases:

\begin{enumerate}
    \item \textbf{Fórmulas $\classSigmaOne$ atómicas} (\namedref{fri:thm:fri-sigmaone} usando \namedref{fri:lemma:tnegr-elim}):
          \[
              \exists \var . \form(\var) \text{ con } \form \text{ atómica.}
          \]
    \item \textbf{Fórmulas $\classPiTwo$ atómicas} (\namedref{fri:thm:fri-pitwo}):

          \[
              \forall \varTwo_1 \dots \forall \varTwo_n . \exists \var . \form(\var, \varTwo_1, \dots, \varTwo_n) \text{ con } \form \text{ atómica}.
          \]

    \item \textbf{Fórmulas $\classPiTwo$ no atómicas} (\namedref{fri:thm:fri-pitwo-general} usando \namedref{fri:lemma:notr-trans-intro}):

          \[
              \forall \varTwo_1 \dots \forall \varTwo_n . \exists \var . \anyForm(\var, \varTwo_1, \dots, \varTwo_n) \text{ con } \anyForm \text{ no atómica}.
          \]

          Por ejemplo, podría ser $\pred(x) \fAnd \predTwo(\varTwo_1, \dots, \varTwo_n)$.
          Pero no podrá ser cualquier fórmula, por ej. no $\fNot \fNot \pred(x)$. En el \namedref{fri:lemma:notr-trans-intro} damos una caracterización.
\end{enumerate}


\begin{lemma}[Eliminación de triple negación relativa]\label{fri:lemma:tnegr-elim}
    $\fNotR\fNotR\fNotR \form \iff \fNotR \form$ y lo demostramos como dos reglas admisibles, una para cada lado

    \begin{multicols}{2}
        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleTNegRE}
            \admissibleRuleLine
            \UnaryInfC{$\fNotR\fNotR\fNotR \form \judgI \fNotR \form$}
        \end{prooftree}

        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleTNegRI}
            \admissibleRuleLine
            \UnaryInfC{$\fNotR \form \judgI \fNotR\fNotR\fNotR \form$}
        \end{prooftree}
    \end{multicols}
\end{lemma}
\begin{proof}

    Primero \ruleTNegRI{}

    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\fNotR \form, \fNotR\fNotR \form \judgI \fNotR \fNotR \form$}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\fNotR \form, \fNotR\fNotR \form \judgI \fNotR \form$}
        \RL{\ruleImpE}
        \BinaryInfC{$\fNotR \form, \fNotR\fNotR \form \judgI R$}
        \RL{\ruleImpI}
        \UnaryInfC{$\fNotR \form \judgI \fNotR\fNotR\fNotR \form$}
    \end{prooftree}

    Ahora \ruleTNegRE{}

    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\fNotR\fNotR\fNotR \form, \form \judgI \fNotR\fNotR\fNotR \form$}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\ctx \judgI \fNotR \form$}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\ctx \judgI \form$}
        \RL{\ruleImpE}
        \BinaryInfC{$\ctx = \fNotR\fNotR\fNotR \form, \form, \fNotR \form \judgI R$}
        \RL{\ruleImpI}
        \UnaryInfC{$\fNotR\fNotR\fNotR \form, \form \judgI \fNotR\fNotR \form$}
        \RL{\ruleImpE}
        \BinaryInfC{$\fNotR\fNotR\fNotR \form, \form \judgI R$}
        \RL{\ruleImpI}
        \UnaryInfC{$\fNotR\fNotR\fNotR \form \judgI \fNotR \form$}
    \end{prooftree}
\end{proof}

\begin{theorem}[Traducción de Friedman para fórmulas $\classSigmaOne$]
    \label{fri:thm:fri-sigmaone}

    Sea $\someProof$ una demostración clásica de $\exists \var . \form$, y
    $\form$ una fórmula atómica.
    Si tenemos
    \[
        \ctx \judgC \exists \var . \form,
    \]
    podemos generar una demostración intuicionista de \textit{la misma fórmula}
    \[
        \transDNeg{\ctx} \judgI \exists \var . \form.
    \]
\end{theorem}
\begin{proof}

    Aplicando la traducción, tenemos que

    \begin{gather*}
        \transDNeg{\big(
            \someProof \proves \ctx \judgC \exists \var . \form
            \big)}\\
        \Updownarrow\\
        \transDNeg{\someProof} \proves \transDNeg{\ctx} \judgI \fNotR \forall \var . \fNotR \fNotR \fNotR \form
    \end{gather*}

    luego, tomando $R = \exists \var . \form$ la fórmula que buscamos probar,

    \begin{align*}
        \transDNeg{\someProof} \proves & \transDNeg{\ctx} \judgI \fNotR \forall \var . \fNotR \fNotR \fNotR \form                                                                                                                  \\
        \iff                           & \transDNeg{\ctx} \judgI \fNotR \forall \var . \fNotR \form
                                       &                                                                                                                    & (\text{\namedref{fri:lemma:tnegr-elim}})                             \\
        =\                             & \transDNeg{\ctx} \judgI (\forall \var . (\form \rightarrow R)) \rightarrow R
                                       &                                                                                                                    & (\fNotR \form = \form \fImp R)                                       \\
        =\                             & \transDNeg{\ctx} \judgI (\forall \var . (\form \rightarrow \exists \var . \form)) \rightarrow \exists \var . \form &                                           & (R = \exists \var \form) \\
        \Rightarrow\                   & \transDNeg{\ctx} \judgI \exists \var . \form
                                       &                                                                                                                    & (\text{\namedref{fri:obs:forall-exists}})
    \end{align*}

    En deducción natural,

    \begin{prooftree}
        \def\defaultHypSeparation{\hskip .1in}
        \AxiomC{$\transDNeg{\someProof}$}
        \noLine
        \UnaryInfC{\(
            \transDNeg{\ctx} \judgI \fNotR \forall \var \fNotR \transDNeg{\form}
            \)}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\transDNeg{\ctx}, \form \judgI \form$}
        \RL{\ruleExistsI}
        \UnaryInfC{$\transDNeg{\ctx}, \form \judgI R = \exists \var \form$}
        \RL{\ruleImpI}
        \UnaryInfC{$\transDNeg{\ctx} \judgI \fNotR \form$}
        \RL{\ruleCutWith{\ruleTNegRI}}
        \admissibleRuleLine
        \UnaryInfC{$\transDNeg{\ctx} \judgI \fNotR \fNotR \fNotR \form$}
        \RL{\ruleForallI}
        \UnaryInfC{\(
            \transDNeg{\ctx} \judgI \forall \var \fNotR \transDNeg{\form}
            \)}
        \RL{\ruleImpE}
        \BinaryInfC{$\transDNeg{\ctx} \judgI \exists \var . \form$}
    \end{prooftree}
\end{proof}

\begin{obs*}
    En la demostración del \namedref{fri:thm:fri-sigmaone} y las de esta sección, luego de aplicar la traducción de Friedman, todas las demostraciones generadas deben ser intuicionistas para que sigan siendo constructivas. No podemos usar \ruleLEM{}.
\end{obs*}

\begin{obs}\label{fri:obs:forall-exists}
    $\judgI \forall \var (\form \rightarrow \exists \var \form)$.
    Trivialmente, para cualquier $\var$ si vale $\form$ entonces va a existir un $\var$ tal que valga $\form$.
\end{obs}

\begin{theorem}[Traducción de Friedman para fórmulas $\classPiTwo$ atómicas]
    \label{fri:thm:fri-pitwo}

    Sea $\someProof$ una demostración clásica de
    \(
    \forall \varTwo_1 \dots \forall \varTwo_n .
    \exists \var .
    \form(\var, \varTwo_1, \dots, \varTwo_n)
    \)
    y $\form$ una fórmula atómica

    Si tenemos
    \[
        \ctx \judgC
        \forall \varTwo_1 \dots \forall \varTwo_n .
        \exists \var .
        \form(\var, \varTwo_1, \dots, \varTwo_n),
    \]
    podemos generar una demostración intuicionista de la misma fórmula
    \[
        \transDNeg{\ctx} \judgI
        \forall \varTwo_1 \dots \forall \varTwo_n .
        \exists \var .
        \form(\var, \varTwo_1, \dots, \varTwo_n).
    \]
\end{theorem}
\begin{proof}
    Lo demostramos en deducción natural para un solo $\forall$. Para una cantidad arbitraria es análoga y fácilmente generalizable a partir de esta. La estrategia consiste en primero introducir el $\forall$ reemplazando su variable por una fresca, para evitar conflictos con las variables usadas en la demostración original. Luego se procede a demostrar el $\exists$ de forma análoga al \namedref{fri:thm:fri-sigmaone}, usando la demostración original traducida pero tomando $R$ como el $\exists$ con la variable ligada por el $\forall$ reemplazada por la fresca en lugar de la fórmula original.

    Tomando $R = \exists \var . \form(\var, \varTwo_0)$ y aplicando la traducción, tenemos que 

    \begin{gather*}
        \transDNeg{\big(
            \someProof \proves \ctx \judgC \forall \varTwo \exists \var . \form(\var, \varTwo)
            \big)}\\
        \Updownarrow\\
        \transDNeg{\someProof} \proves
            \transDNeg{\ctx} \judgI
                \forall \varTwo \fNotR \forall \var . \fNotR \fNotR \fNotR \form(\var, \varTwo)
    \end{gather*}

    Luego

    \begin{prooftree}
        \AxiomC{$\tdn{\someProof}$}
        \noLine
        \UnaryInfC{$\tdn{\ctx} \judgI \forall \varTwo \fNotR \forall \var . \fNotR \tdn{\form(\var, \varTwo_0)}$}
        \RL{\ruleForallE}
        \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \forall \var . \fNotR \tdn{\form(\var, \varTwo_0)}$}
        %
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(
            \tdn{\ctx}, \form(\var, \varTwo_0) \judgI \form(\var, \varTwo_0)
        \)}
        \RL{\ruleExistsI}
        \UnaryInfC{\(
            \tdn{\ctx}, \form(\var, \varTwo_0) \judgI R = \exists \var . \form(\var, \varTwo_0)
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR \form(\var, \varTwo_0)
        \)}
        \RL{\ruleCutWith{\ruleTNegRI}}
        \admissibleRuleLine
        \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \fNotR \fNotR \form(\var, \varTwo_0)$}
        \RL{\ruleForallI}
        \UnaryInfC{$\tdn{\ctx} \judgI\forall \var . \fNotR \tdn{\form(\var, \varTwo_0)}$}
        \RL{\ruleImpE}
        \BinaryInfC{$\tdn{\ctx} \judgI \exists \var . \form(\var, \varTwo_0)$}
        \RL{\ruleForallI}
        \UnaryInfC{$\tdn{\ctx} \judgI \forall \varTwo \exists \var . \form(\var, \varTwo)$}
    \end{prooftree}
\end{proof}

\begin{corollary}[Instanciación de $\forall$]
    \label{fri:cor:forall-inst-old}
    El \namedref{fri:thm:fri-pitwo} nos permite realizar la instanciación de las variables del $\forall$ por cualquier término usando \ruleForallE{}. De esa forma, la demostración final es sobre un $\exists$, requerido para poder hacer la extracción sobre la demostración normalizada.
    Por ejemplo,
    \begin{prooftree}
        \AxiomC{(\ref{fri:thm:fri-pitwo})}
        \noLine
        \UnaryInfC{$\tdn{\ctx} \judgI \forall \varTwo \exists \var . \form(\var, \varTwo)$}
        \RL{\ruleForallE}
        \UnaryInfC{$\tdn{\ctx} \judgI \exists \var . \form(\var, \term)$}
    \end{prooftree}
\end{corollary}

\subsection{Traducción de Friedman para formulas no atómicas}

Hasta ahora usamos la traducción de Friedman para traducir las demostraciones de una fórmula de clásica a intuicionista, manteniendo esa fórmula, siempre y cuando su sub-fórmula $\classSigma{0}$ sea \textbf{atómica}. Pero queremos generalizarlo a fórmulas como $\forall \varTwo \exists \var . \anyForm(\var, \varTwo)$ donde $\anyForm$ no sea atómica, por ejemplo $\form(\var) \fAnd \formTwo(\varTwo)$. Para ello, la única diferencia es en el uso de \ruleCut{}. Para fórmulas atómicas, tenemos

\begin{prooftree}
    \AxiomC{$\vdots$}
    \noLine
    \UnaryInfC{\(
        \tdn{\ctx} \judgI \fNotR \form
    \)}
    \RL{\ruleCutWith{\ruleTNegRI}}
    \admissibleRuleLine
    \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \tdn{\form} = \fNotR \fNotR \fNotR \tdn{\form}$}
\end{prooftree}

En donde aprovechamos que la traducción de fórmulas atómicas es $\fNotR \tdn{\form} = \fNotR \fNotR \fNotR \form$ y podemos llevarla a $\fNotR \form$ mediante la eliminación de la triple negación (\ruleTNegRI{}). Pero esto no es así para fórmulas no atómicas. Para ello, enunciamos el \namedref{fri:lemma:notr-trans-intro}, el cual podemos usar para demostrar la traducción en el \namedref{fri:thm:fri-pitwo-general}.

\begin{lemma}[Congruencia de $\fNotR\fNotR$]
    \label{fri:lemma:dnegr-cong}
    Si $\form \judgI \form'$, luego $\fNot \fNot \form \judgI \fNot \fNot \form'$.
\end{lemma}

\begin{lemma}[Distributividad del $\fNotR$ sobre $\fAnd$]
    \label{fri:lemma:fnot-dist-over-and-right}
    \(
    \fNotR \form \fOr \fNotR \formTwo \judgI \fNotR(\form \fAnd \formTwo)
    \)
\end{lemma}

\begin{lemma}[Introducción de $\fNotR$]
    \label{fri:lemma:notr-trans-intro}
    Para algunas fórmulas $\form$, vale $\fNotR \form \judgI \fNotR \tdn{\form}$ y lo notamos con la regla admisible \ruleNotRTransI{}.
    
    No vale siempre, ya que en ese caso podríamos usar la traducción de Friedman para todas las fórmulas, y sabemos que no es posible. Lo demostramos para las fórmulas descritas por la siguiente gramática (conjunciones y fórmulas atómicas)
    \[
        \form ::=
            \fFalse \mid \fTrue \mid \pred(\term_1, \dots, \term_n)
            \mid \form \fAnd \form
    \]

    donde $\term_i$ son términos
\end{lemma}
\begin{proof}
    La demostración es por inducción estructural en la fórmula.
    \begin{itemize}
        \item $\fFalse, \fTrue$ son triviales. Predicados con \ruleTNegRI{}.
        \item $\fNot, \fOr, \fImp, \exists, \forall$ no están demostradas. Debería ser posible para algunas, pero no es claro.
        \item $\fAnd$ es cierta para sub-fórmulas que cumplan con la hipótesis inductiva. Tiene algunos trucos.
    \end{itemize}

    Veamos esquemáticamente la demostración del $\fAnd$.
    \begin{itemize}
        \item Debemos probar $\fNotR (\form \fAnd \formTwo) \judgI \fNotR \tdn{(\form \fAnd \formTwo)}$
        \item Intuitivamente, queremos llevarlo a $\fNotR (\form \fAnd \formTwo) \judgI \fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo}$. En lógica clásica esta demostración requiere el uso de LEM, en particular  \ruleDnegE{} para razonar por el absurdo, que no vale para lógica intuicionista.
        \item Pero podemos usar un truco para razonar por el absurdo.
        \begin{itemize}
        \item Tenemos que $\fNotR \tdn{(\form \fAnd \formTwo)}$ es siempre equivalente a $\fNotR \fNotR (\fNotR \tdn{(\form \fAnd \formTwo)})$ por eliminación de triple negación.
        \item Podemos usar dos lemas auxiliares: $\fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo} \judgI \fNotR \tdn{(\form \fAnd \formTwo)}$ (\ref{fri:lemma:fnot-dist-over-and-right}) y la congruencia de la doble negación, que al ser doble es covariante: $\form \judgI \form' \Rightarrow \fNotR \fNotR \form \judgI \fNotR \fNotR \form'$ (\ref{fri:lemma:dnegr-cong}) para demostrar 
        \[
            \fNotR \fNotR (\fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo})
            \judgI
            \fNotR \fNotR (\fNotR \tdn{(\form \fAnd \formTwo)})
        \]
        \end{itemize}
        \item Esto nos permite llevar $\fNotR (\form \fAnd \formTwo) \judgI \fNotR \tdn{(\form \fAnd \formTwo)}$ a \[\fNotR (\form \fAnd \formTwo) \judgI \fNotR \fNotR (\fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo})\]
        
        que se puede demostrar por el absurdo de forma análoga a la demostración clásica bien conocida.
    \end{itemize}

    En deducción natural,
    \begin{prooftree}
        \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{}
        \RL{(\ref{fri:lemma:fnot-dist-over-and-right})}
        \UnaryInfC{\(
            \fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo}
            \judgI
            \fNotR \tdn{(\form \fAnd \formTwo)}
        \)}
        \RL{(\ref{fri:lemma:dnegr-cong})}
        \UnaryInfC{\(
            \fNotR \fNotR (\fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo})
            \judgI
            \fNotR \fNotR \fNotR \tdn{(\form \fAnd \formTwo)}
        \)}
        \AxiomC{\(\begin{gathered}
            \vdots\\
            \text{\textit{(dem por el absurdo)}}
        \end{gathered}
        \)}
        \noLine
        \UnaryInfC{\(
            \ctx, \fNotR (\fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo}) \judgI
            R
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \ctx \judgI
            \fNotR \fNotR (\fNotR \tdn{\form} \fOr \fNotR \tdn{\formTwo})
        \)}
        \RL{\ruleCut}
        \admissibleRuleLine
        \BinaryInfC{\(
            \ctx \judgI
            \fNotR \fNotR \fNotR \tdn{(\form \fAnd \formTwo)}
        \)}
        \RL{\ruleCutWith{\ruleTNegRE}}
        \admissibleRuleLine
        \UnaryInfC{\(
            \ctx = \fNotR (\form \fAnd \formTwo) \judgI \fNotR \tdn{(\form \fAnd \formTwo)}
        \)}
    \end{prooftree}
\end{proof}

\begin{theorem}[Traducción de Friedman para fórmulas $\classSigmaOne$ en general]
    \label{fri:thm:fri-pitwo-general}

    Sea $\someProof$ una demostración clásica de \(
    \forall \varTwo_1 \dots \forall \varTwo_n .
    \exists \var .
    \anyForm(\var, \varTwo_1, \dots, \varTwo_n)
    \), y
    $\anyForm(\var, \varTwo_1, \dots, \varTwo_n)$ una fórmula no atómica.
    Si tenemos
    \[
        \ctx \judgC
        \forall \varTwo_1 \dots \forall \varTwo_n .
        \exists \var .
        \anyForm(\var, \varTwo_1, \dots, \varTwo_n),
    \]
    podemos generar una demostración intuicionista de la misma fórmula
    \[
        \transDNeg{\ctx} \judgI
        \forall \varTwo_1 \dots \forall \varTwo_n .
        \exists \var .
        \anyForm(\var, \varTwo_1, \dots, \varTwo_n).
    \]
\end{theorem}
\begin{proof}
    Al igual que el \namedref{fri:thm:fri-pitwo} lo demostramos para un solo $\forall$. La demostración es análoga con la diferencia del uso del \namedref{fri:lemma:notr-trans-intro}: \ruleNotRTransI{}. En lugar de tener
    
    \begin{prooftree}
        \AxiomC{$\vdots$}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR \form
        \)}
        \RL{\ruleCutWith{\ruleTNegRI}}
        \admissibleRuleLine
        \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \tdn{\form} = \fNotR \fNotR \fNotR \tdn{\form}$}
    \end{prooftree}

    tenemos

    \begin{prooftree}
        \AxiomC{$\vdots$}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR \anyForm
        \)}
        \RL{\ruleCutWith{\ruleNotRTransI}}
        \admissibleRuleLine
        \UnaryInfC{$\tdn{\ctx} \judgI \fNotR \tdn{\anyForm}$}
    \end{prooftree}
\end{proof}

\begin{corollary}[Traducción de Friedman con instanciación de $\forall$]
    \label{fri:cor:forall-inst}
    De la misma forma que el \namedref{fri:cor:forall-inst-old}, podemos usar el \namedref{fri:thm:fri-pitwo-general} para tener la \textbf{versión final de la traducción}, que deja las demostraciones listas para la extracción de testigos.

    Sea $\someProof$ una demostración clásica de \(
    \forall \varTwo_1 \dots \forall \varTwo_n .
    \exists \var .
    \anyForm(\var, \varTwo_1, \dots, \varTwo_n)
    \). Si tenemos
    \[
        \ctx \judgC
        \forall \varTwo_1 \dots \forall \varTwo_n .
        \exists \var .
        \anyForm(\var, \varTwo_1, \dots, \varTwo_n),
    \]
    podemos generar una demostración intuicionista de la misma fórmula, instanciando las variables cuantificadas universalmente por términos $\term_1, \dots, \term_n$ cualesquiera (a elección del usuario)
    \[
        \transDNeg{\ctx} \judgI
        \exists \var .
        \anyForm(\var, \term_1, \dots, \term_n).
    \]
\end{corollary}

\subsection{Traducción de demostraciones}
\label{fri:sec:proof-trans}

Ya vimos como podemos usar la traducción de Friedman para, dada una traducción de la demostración clásica original, usarla para demostrar la misma fórmula de forma intuicionista. Pero aún no ahondamos en un detalle importante. En el \namedref{fri:thm:dneg-trans-classic-int} se introduce la necesidad de extender la traducción de doble negación relativizada de fórmulas a demostraciones, para poder realizar la traducción de una demostración clásica a intuicionista. En esta sección lo vemos más en detalle.

La conversión se efectúa por inducción estructural en la demostración. Para cada regla de inferencia que demuestra $\form$, se genera una demostración a partir de ella para demostrar $\transDNeg{\form}$. La estrategia para hacerlo es similar para todas: recursivamente convertir las sub-demostraciones, y usarlas para generar la nueva. Pero hay algunas un poco rebuscadas.

\begin{itemize}
    \item \ruleAndI{} (\namedref{fri:lemma:trad-and-i}), \ruleAndEOne{}, \ruleAndETwo{}, \ruleImpI{}, \ruleImpE{},
          \ruleOrIOne{}, \ruleOrITwo{}, \ruleForallI{}, \ruleForallE{}, \ruleNotI{}, \ruleNotE{}, \ruleTrueI{}, \ruleAx{} son todas similares entre sí, por lo que solo mostramos una.
    \item \ruleExistsI{} (\namedref{fri:lemma:trad-exists-i}) es una regla simple pero más interesante que las anteriores, por la traducción de $\exists$.
    \item \ruleLEM{} (\namedref{fri:lemma:trad-lem}) es sumamente interesante, ya que se encuentra en el corazón de la traducción: ¿cómo traducimos el principio de razonamiento clásico que lo separa de la lógica intuicionista?
    \item \ruleFalseE{} (\namedref{fri:lemma:trad-false-e})  se prueba como lema por inducción estructural en la fórmula a demostrar.
    \item \ruleOrE{} (\namedref{fri:lemma:trad-or-e}) y \ruleExistsE{} son análogos y requieren un truco: usar la eliminación de la doble negación. Si bien al ser un principio de razonamiento clásico no vale para lógica intuicionista (por ser equivalente a LEM), lo que si vale es la eliminación de la doble negación relativizada: \ruleDnegRE{} (\namedref{fri:lemma:dnegr-e}).
\end{itemize}

\begin{lemma}[Traducción de \ruleAndI{}]
    \label{fri:lemma:trad-and-i}
    Dada una aparición de la regla \ruleAndI{},

    \begin{prooftree}
        \AxiomC{$\someProof_\form$}
        \noLine
        \UnaryInfC{$\ctx \judgI \form$}
        \AxiomC{$\someProof_\formTwo$}
        \noLine
        \UnaryInfC{$\ctx \judgI \formTwo$}
        \RL{\ruleAndI}
        \BinaryInfC{$\ctx \judgI \form \wedge \formTwo$}
    \end{prooftree}

    es posible traducirla generando una demostración de $\tdn{(\form \fAnd \formTwo)} = \tdn{\form} \fAnd \tdn{\formTwo}$.
\end{lemma}
\begin{proof}
    Por hipótesis inductiva, tenemos que
    \begin{align*}
        \tdn{\someProof_\form} \proves
        \tdn{\ctx} &\judgI
        \tdn{\form}\\
        \tdn{\someProof_\formTwo} \proves
        \tdn{\ctx} &\judgI
        \tdn{\formTwo}
    \end{align*}

    Luego, podemos generar una demostración de $\tdn{\form} \fAnd \tdn{\formTwo}$

    \begin{prooftree}
        \AxiomC{$\tdn{\someProof_\form}$}
        \noLine
        \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\form}$}
        \AxiomC{$\tdn{\someProof_\formTwo}$}
        \noLine
        \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\formTwo}$}
        \RL{\ruleAndI}
        \BinaryInfC{$\tdn{\ctx} \judgI \tdn{\form} \fAnd \tdn{\formTwo}$}
    \end{prooftree}
\end{proof}

\begin{lemma}[Traducción de \ruleExistsI{}]
    \label{fri:lemma:trad-exists-i}
    Dada una aparición de la regla \ruleExistsI{},

    \begin{prooftree}
        \AxiomC{$\someProof$}
        \noLine
        \UnaryInfC{$\judg{\ctx}{\form\subst{\var}{\term}}$}
        \RL{\ruleExistsI}
        \UnaryInfC{$\judg{\ctx}{\exists \var. \form}$}
    \end{prooftree}

    es posible traducirla generando una demostración de $\tdn{\exists \var. \form} = \fNotR \forall \var . \fNotR \tdn{\form}$.
\end{lemma}
\begin{proof}
    Por hipótesis inductiva, tenemos que
    \[
        \tdn{\someProof} \proves
        \tdn{\ctx} \judgI
        \tdn{(\form \subst{\var}{\term})}
    \]

    Luego, podemos generar una demostración de $\fNotR \forall \var . \fNotR \tdn{\form}$

    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(
            \ctx_1 \judgI \fNotR \forall \var \tdn{\form}
        \)}
        \RL{\ruleForallE}
        \UnaryInfC{\(
            \ctx_1 \judgI \fNotR \tdn{(\form \subst{\var}{\term})}
        \)}
        \AxiomC{$\tdn{\someProof}$}
        \noLine
        \UnaryInfC{\(
            \ctx_1 \judgI \tdn{(\form \subst{\var}{\term})}
        \)}
        \RL{\ruleImpE}
        \BinaryInfC{\(
            \ctx_1 = \tdn{\ctx}, \forall \var . \fNotR \tdn{\form} \judgI R
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR \forall \var . \fNotR \tdn{\form}
        \)}
    \end{prooftree}

\end{proof}

\begin{lemma}[Traducción de \ruleLEM{}]
    \label{fri:lemma:trad-lem}
    Dada una aparición de la regla \ruleLEM{},

    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleLEM}
        \UnaryInfC{$\judg{\ctx}{\form \fOr \fNot \form}$}
    \end{prooftree}

    es posible traducirla generando una demostración de
    \[
        \tdn{(\form \fOr \fNot \form)}
        = \fNotR (\fNotR \tdn{\form} \fAnd \fNotR \fNotR \tdn{\form}).
    \]
\end{lemma}
\begin{proof}
    Como no hay HI, podemos demostrarlo para cualquier contexto $\ctx$.
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(
            \ctx_1
            \judgI \fNotR \tdn{\form} \fAnd \fNotR \fNotR \tdn{\form}
        \)}
        \RL{\ruleAndETwo}
        \UnaryInfC{\(
            \ctx_1
            \judgI \fNotR \fNotR \tdn{\form}
        \)}
        %
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(
            \ctx_1
            \judgI \fNotR  \tdn{\form} \fAnd \fNotR \fNotR \tdn{\form}
        \)}
        \RL{\ruleAndEOne}
        \UnaryInfC{\(
            \ctx_1
            \judgI \fNotR \tdn{\form}
        \)}
        \RL{\ruleImpE}
        \BinaryInfC{\(
            \ctx_1 = \ctx,
            \fNotR \tdn{\form} \fAnd \fNotR \fNotR \tdn{\form}
            \judgI R
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \ctx \judgI
                \fNotR (\fNotR \tdn{\form} \fAnd \fNotR \fNotR \tdn{\form})
        \)}
    \end{prooftree}
\end{proof}
\begin{lemma}[Traducción de \ruleFalseE{}]
    \label{fri:lemma:trad-false-e}
    Dada una aparición de la regla \ruleFalseE{},

    \begin{prooftree}
        \AxiomC{$\someProof_\fFalse$}
        \noLine
        \UnaryInfC{$\judg{\ctx}{\fFalse}$}
        \RL{\ruleFalseE}
        \UnaryInfC{$\judg{\ctx}{\anyForm}$}    
    \end{prooftree}

    es posible generar una demostración de $\tdn{\anyForm}$ a partir de $\tdn{\fFalse} = R$.
\end{lemma}
\begin{proof}
    Por hipótesis inductiva (de inducción estructural sobre la demostración), tenemos que
    \begin{gather*}
        \tdn{(\someProof_\fFalse \proves \ctx \judgC \fFalse)}
        \\
        \Updownarrow
        \\
        \tdn{\someProof_\fFalse} \proves \tdn{\ctx} \judgI \tdn{\fFalse}
        \\
        \Updownarrow
        \\
        \someProof_R \proves \tdn{\ctx} \judgI R
    \end{gather*}
    Pero no es posible demostrar de forma directa $\tdn{\anyForm}$ a partir de $R$. Lo hacemos por inducción estructural en $\anyForm$. Todos los casos son parecidos. Por ejemplo, veamos un caso inductivo y uno base.
    
    \begin{itemize}
    \item Dada una conjunción $\form \fAnd \formTwo$, su traducción es $\tdn{\form} \fAnd \tdn{\formTwo}$. Por HI (de inducción estructural sobre la fórmula) a partir de $\someProof_R$ podemos probar $\tdn{\form}$ al igual que $\tdn{\formTwo}$. Luego,

    \begin{prooftree}
        \AxiomC{(HI)}
        \noLine
        \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\formTwo}$}
        \AxiomC{(HI)}
        \noLine
        \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\form}$}
        \RL{\ruleAndI}
        \BinaryInfC{$\tdn{\ctx} \judgI \tdn{\form} \fAnd \tdn{\formTwo}$}
    \end{prooftree}
    

    \item Dada una disyunción $\form \fOr \formTwo$, su traducción es $\fNotR (\fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo})$. Luego, podemos demostrarlo sin usar la HI.
    
    \begin{prooftree}
        \AxiomC{$\someProof_R$}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo} \judgI R
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR (\fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo})
        \)}
    \end{prooftree}
    \end{itemize}

    El resto de los casos son análogos.
\end{proof}

\begin{lemma}[Eliminación de doble negación relativizada]
    \label{fri:lemma:dnegr-e}
    Para toda fórmula $\form$, vale
    \[
        \fNotR \fNotR \tdn{\form} \judgI \tdn{\form}.
    \]

    Y se define como regla admisible \ruleDnegRE{}.
\end{lemma}
\begin{proof}
    Se demuestra por inducción estructural en la estructura de $\form$ (sin traducir).
    \begin{itemize}
        \item $\fFalse, \fTrue$ son triviales.
        \item Predicados, $\fNot, \exists, \fOr$ son todas iguales: como su traducción comienza por $\fNotR$, su doble negación es una triple negación, y se puede demostrar con el \fullref{fri:lemma:tnegr-elim}.
        \item $\fAnd, \fImp, \forall$ mantienen su forma luego de la traducción, y su demostración usa la misma técnica. Veamos por ejemplo el caso de la conjunción $\form \fAnd \formTwo$. Por HI tenemos que
        \begin{align*}
            \fNotR \fNotR \tdn{\form} &\judgI \tdn{\form}\\
            \fNotR \fNotR \tdn{\formTwo} &\judgI \tdn{\formTwo}
        \end{align*}
        Luego, introducimos la conjunción y usamos la hipótesis inductiva en cada una para razonar por el absurdo. Esto es análogo a como usamos \ruleDnegE{} para razonar por el absurdo en lógica clásica en el \fullref{ppa:sec:abs-reasoning}.
        
        \begin{prooftree}
            \AxiomC{$\someProof_L$}
            \noLine
            \UnaryInfC{\(
                \fNotR \fNotR \tdn{(\form \fAnd \formTwo)} \judgI \tdn{\form}
            \)}
            %
            \AxiomC{$\someProof_R$}
            \noLine
            \UnaryInfC{\(
                \fNotR \fNotR \tdn{(\form \fAnd \formTwo)} \judgI \tdn{\formTwo}
            \)}
            \BinaryInfC{\(
                \fNotR \fNotR \tdn{(\form \fAnd \formTwo)} \judgI
                \tdn{\form} \fAnd \tdn{\formTwo}
            \)}
        \end{prooftree}

        donde $\someProof_L$ y $\someProof_R$ son simétricas, y

        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{\(
                \ctx \judgI
                \fNotR \fNotR \tdn{(\form \fAnd \formTwo)}
            \)}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{\(
                \ctx_1 \judgI \fNotR \tdn{\form}
            \)}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{\(
                \ctx_1 \judgI \tdn{\form} \fAnd \tdn{\formTwo}
            \)}
            \RL{\ruleAndEOne}
            \UnaryInfC{\(
                \ctx_1 \judgI \tdn{\form}
            \)}
            \RL{\ruleImpE}
            \BinaryInfC{\(
                \ctx_1 = \ctx, \tdn{(\form \fAnd \formTwo)} \judgI R
            \)}
            \RL{\ruleImpI}
            \UnaryInfC{\(
                \ctx \judgI \fNotR \tdn{(\form \fAnd \formTwo)}
            \)}
            \RL{\ruleImpE}
            \BinaryInfC{\(
                \ctx = \fNotR \fNotR \tdn{(\form \fAnd \formTwo)}, \fNotR \tdn{\form}
                \judgI R
            \)}
            \RL{\ruleImpI}
            \UnaryInfC{\(
                \fNotR \fNotR \tdn{(\form \fAnd \formTwo)} \judgI
                    \fNotR \fNotR \tdn{\form}
            \)}
            \RL{\ruleCutWith{(HI)}}
            \admissibleRuleLine
            \LL{$\someProof_L=$}
            \UnaryInfC{\(
                \fNotR \fNotR \tdn{(\form \fAnd \formTwo)} \judgI \tdn{\form}
            \)}
        \end{prooftree}
    \end{itemize}
\end{proof}

\begin{lemma}[Traducción de \ruleOrE{}]
    \label{fri:lemma:trad-or-e}
    Dada una aparición de la regla \ruleOrE{},

    \begin{prooftree}
        \AxiomC{$\someProof_\fOr$}
        \noLine
        \UnaryInfC{$\judg{\ctx}{\form \fOr \formTwo}$}
        \AxiomC{$\someProof_L$}
        \noLine
        \UnaryInfC{$\judg{\ctx, \form}{\formThree}$}
        \AxiomC{$\someProof_R$}
        \noLine
        \UnaryInfC{$\judg{\ctx, \formTwo}{\formThree}$}
        \RL{\ruleOrE}
        \TrinaryInfC{$\judg{\ctx}{\formThree}$}    
    \end{prooftree}

    podemos usarla para demostrar $\tdn{\formThree}$ a partir de las sub-demostraciones traducidas.
\end{lemma}
\begin{proof}
    Por HI, tenemos
    \begin{align*}
        \tdn{\someProof_\fOr} \proves
            \tdn{\ctx} &\judgI \tdn{(\form \fOr \formTwo)}
            = \fNotR (\fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo})
            \\
        \tdn{\someProof_L} \proves \tdn{(\ctx, \form)} &\judgI \tdn{\formThree}\\
        \tdn{\someProof_R} \proves \tdn{(\ctx, \formTwo)} &\judgI \tdn{\formThree}
    \end{align*}

    Luego, podemos generar una demostración de $\tdn{\formThree}$ por el absurdo usando \ruleDnegRE{} (\namedref{fri:lemma:dnegr-e}).

    \begin{prooftree}
        \AxiomC{$\tdn{\someProof_\fOr}$}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\formThree} \judgI 
            \fNotR (\fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo})
        \)}
        \AxiomC{$\someProofTwo$}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\formThree}
            \judgI \fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo}
        \)}
        \RL{\ruleImpE}
        \BinaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\formThree} \judgI R
        \)}
        \RL{\ruleImpI}
        \UnaryInfC{\(
            \tdn{\ctx} \judgI \fNotR \fNotR \tdn{\formThree} 
        \)}
        \RL{\ruleCutWith{\ruleDnegRE}}
        \admissibleRuleLine
        \UnaryInfC{$\tdn{\ctx} \judgI \tdn{\formThree}$}
    \end{prooftree}

    Donde

    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{\(
            \ctx_1 \judgI\fNotR \tdn{\formThree}
        \)}
        \AxiomC{$\tdn{\someProof_L}$}
        \noLine
        \UnaryInfC{\(
            \ctx_1 \judgI \tdn{\formThree}
        \)}
        \RL{\ruleImpE}
        \BinaryInfC{\(
            \ctx_1 = \tdn{\ctx}, \fNotR \tdn{\formThree}, \tdn{\form} \judgI R
        \)}
        \RL{\ruleNotI}
        \UnaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\formThree}
            \judgI \fNotR \tdn{\form}
        \)}
        %
        \AxiomC{\(
            \begin{gathered}
                \vdots\\
                \text{\textit{(simétrico)}}
            \end{gathered}
        \)}
        \noLine
        \UnaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\formThree}
            \judgI \fNotR \tdn{\formTwo}
        \)}
        \RL{\ruleAndI}
        \LL{$\someProofTwo=$}
        \BinaryInfC{\(
            \tdn{\ctx}, \fNotR \tdn{\formThree}
            \judgI \fNotR \tdn{\form} \fAnd \fNotR \tdn{\formTwo}
        \)}
    \end{prooftree}
\end{proof}

\section{Normalización (o reducción)}
\label{fri:sec:reduction}

Repasemos en dónde estamos parados. Queremos extraer un testigo de la demostración de un existencial (i.e extraer de una demostración de  $\exists \var . \pred(\var)$ a un $\term$ tal que $\pred(\term)$). Partimos de una demostración escrita en el lenguaje de alto nivel PPA, que se certifica a una demostración en deducción natural \textit{clásica} (que tiene el problema para la reducción que no es constructiva). Mediante la traducción de Friedman, para cierto tipo de fórmulas ($\classPiTwo$), podemos convertir la demostración a \textit{intuicionista}. Ahora, queremos extraer el testigo a partir de ella. Eso lo podemos lograr \textbf{normalizando} la demostración. ¿Cómo funciona?

Intuitivamente, la estrategia que empleamos consiste en evitar \textit{desvíos superfluos} en una demostración, sucesivamente simplificándolos hasta que queda una sin desvíos, que estará en \textbf{forma normal}. Por ejemplo, en la siguiente demostración se prueba $\form \fImp \form$ usando $(\form \fImp \form) \fAnd (\formTwo \fImp \formTwo)$ y demostrándo ambos por separado. Pero se puede demostrar de forma más directa, usando la demostración de $\form \fImp \form$ y eliminado el desvío por el $\fAnd$.

\begin{figure}[H]
\[
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{$\form \judG \form$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judG \form \fImp \form$}
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{$\formTwo \judG \formTwo$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judG \formTwo \fImp \formTwo$}
    \RL{\ruleAndI}
    \BinaryInfC{$\judG (\form \fImp \form) \fAnd (\formTwo \fImp \formTwo)$}
    \RL{\ruleAndEOne{}}
    \UnaryInfC{$\judG \form \fImp \form$}
\DisplayProof
\quad
\rewrite
\quad
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{$\form \judG \form$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judG \form \fImp \form$}
    \DisplayProof
\]
\caption{Ejemplo de desvío y su normalización}
\end{figure}

Todos los desvíos que normalizamos se ven de esta forma: una \textbf{eliminación} seguida inmediatamente de su \textbf{introducción} correspondiente. Por ejemplo, \ruleAndEOne{} seguida de \ruleAndI{}.

Este proceso es análogo a las reducciones de cálculo $\lambda$. Y no solo
análogo, sino que existe un \textit{isomorfismo} entre demostraciones en
deducción natural y términos de cálculo $\lambda$: El isomorfismo Curry-Howard
\cite{curry-howard-isomorphism}. Con él, la normalización de demostraciones isomorfa a las reducciones en cálculo $\lambda$, su semántica operacional. Por
ejemplo, el isomorfismo nos permite pensar en una conjunción como una tupla, y
las eliminaciones como proyecciones. Luego, podemos ver cómo la regla de
normalización de la conjunción es isomorfa a la regla de reducción de las
proyecciones.

\begin{figure}[H]
    \begin{align*}
        \projectOne{\tuple{\lTerm_1}{\lTerm_2}} &\rewrite \lTerm_1\\
        \projectTwo{\tuple{\lTerm_1}{\lTerm_2}} &\rewrite \lTerm_2
    \end{align*}
    
    \[
        \reductionAnd
    \]
    \caption{Relación entre conjunciones y tuplas}
\end{figure}

De acá en adelante presentamos las reducciones directamente en deducción
natural, dado que es lo implementado en \ppaTool{}. Usamos de forma intercambiable
\textit{reducción} y \textit{normalización}, pues en el fondo, son lo mismo.

\begin{obs*}
    Es interesante notar que en las reducciones mencionadas en esta sección, no
    se explicita ni $\judgI$ ni $\judgC$ a diferencia de la traducción de
    Friedman. Esto es porque la normalización se puede ejecutar en ambos casos,
    con la diferencia de que si lo hacemos para una demostración de lógica
    clásica que use \ruleLEM{}, se traba cuando llega ahí y su forma normal no
    es muy útil.
\end{obs*}

\subsection{Sustituciones}

No todas las reglas de reducción son igual de sencillas que $\fAnd$. Veamos el
caso de la implicación. Una eliminación seguida de una introducción tiene la siguiente forma.

\begin{prooftree}
    \AxiomC{$\someProof_\formTwo$}
    \noLine
    \UnaryInfC{$\ctx, \hypId: \form \judG \formTwo$}
    \RL{\ruleImpIh{\hypId}}
    \UnaryInfC{$\ctx \judG \form \fImp \formTwo$}
    \AxiomC{$\someProof_\form$}
    \noLine
    \UnaryInfC{$\ctx \judG \form$}
    \RL{\ruleImpE}
    \BinaryInfC{$\ctx \judG \formTwo$}
\end{prooftree}

Para eliminar el desvío, uno podría estar tentado a hacer directamente $\someProof_\formTwo \proves \ctx \judG \formTwo$ pero ¡\textbf{no sería correcto}! La demostración $\someProof_\formTwo$ requiere la hipótesis $\hypId : \form$, que no necesariamente está en $\ctx$, es agregada por \ruleImpIh{\hypId}. Lo correcto sería usar $\someProof_\formTwo$, pero reemplazando todas las ocurrencias de la hipótesis $\hypId$ por la demostración $\someProof_\form$. Es necesaria una noción de sustitución de \textit{hipótesis} por demostraciones.

\begin{definition}[Hipótesis libres]
    Una hipótesis ocurre libre en una demostración si se cita sin ser definida. Las reglas que etiquetan y agregan hipótesis al contexto son las que las ligan (i.e. las mencionadas en \fullref{nd:sec:hyp-labels}: \ruleAxh{\hypId}, \ruleImpIh{\hypId}, \ruleNotIh{\hypId}, \ruleOrEh{\hypId}, \ruleExistsEh{\hypId})
\end{definition}

\begin{definition}[Hipótesis citadas por una demostración]
    Definimos el conjunto de hipótesis citadas por una demostración $\citedHyps{\someProof}$ como todas las hipótesis ligadas y libres que aparecen en ella.
\end{definition}

\begin{definition}[Sustitución de hipótesis]
    Notamos como \(\someProof \subst{\hypId}{\someProof'}\) a la sustitución sin capturas de todas las ocurrencias libres de una hipótesis $\hypId$ por una demostración $\someProofTwo$ en otra demostración $\someProof$. Una \textit{captura} ocurriría si en alguna sub-demostración de $\someProof$ se liga una hipótesis $\hypId_2 \neq \hypId$ tal que $\hypId_2 \in \citedHyps{\someProofTwo}$ (se cite en $\someProofTwo$).
    
    Para evitar la captura, al igual que en la sustitución de variables, no podemos renombrar en $\someProofTwo$ (porque la hipótesis está libre), sino que en la sub-demostración de $\someProof$ que liga $\hypId_2$ introduciendo el conflicto la renombramos por una fresca $\hypId_2'$.
\end{definition}

\duda{Pensamiento: Si no tuvieramos etiquetas, esta sustitución sería más fácil, no? Porque en lugar de reemplazar por ocurrencias de la etiqueta, reemplazas por veces que citas en un axioma una \textit{fórmula}, entonces si lo estás capturando te da igual, total es la misma fórmula. O se podrá romper?}

Además, para la reducción del $\exists$ y $\forall$, necesitaremos extender la
sustitución usual de variables por términos (\namedref{nd:def:subst}) a
demostraciones. La implementación es análoga, evitando capturas y haciéndolo en
una pasada de forma lineal.
\begin{definition}[Sustitución de variables en demostraciones]
    Notamos como $\someProof \subst{\var}{\term}$ a la sustitución sin capturas de todas las ocurrencias libres de una variable $\var$ por un término $\term$ en toda una demostración $\someProof$. Incluyendo los contextos.
    
    \duda{Hace falta definirlo más?}
\end{definition}

\subsection{Algoritmo de reducción}

\begin{figure}
    $$\reductionAnd$$
    \proofSpacing
    \[
        \reductionImp
    \]
    \duda{Por qué no directamente así?
        \AxiomC{$\someProof_\formTwo \subst{\hypId}{\someProof_\form}$}
        \noLine
        \UnaryInfC{$\ctx \judG \formTwo$}
        \DisplayProof
    }
    \proofSpacing
    \begin{gather*}
        \AxiomC{$\someProof_{\form_i}$}
    \noLine
    \UnaryInfC{$\ctx \judG \form_i$}
    \RL{\ruleOrI{i}}
    \UnaryInfC{$\ctx \judG \form_1 \fOr \form_2$}
    \AxiomC{$\someProof_{1}$}
    \noLine
    \UnaryInfC{$\ctx, \hypId_1 : \form_1 \judG \formTwo$}
    \AxiomC{$\someProof_{2}$}
    \noLine
    \UnaryInfC{$\ctx, \hypId_2 : \form_2 \judG \formTwo$}
    \RL{\ruleOrE{}}
    \TrinaryInfC{$\ctx \judG \formTwo$}
    \DisplayProof\\
    \rewrite \quad
    \left(
    \AxiomC{$\someProof_i$}
    \noLine
    \UnaryInfC{$\ctx, \hypId_i: \form_i \judG \formTwo$}
    \DisplayProof
    \right)\subst{\hypId_i}{\someProof_{\form_i}}
    \end{gather*}

    \[\reductionNot\]
    \proofSpacing
    \[
        \AxiomC{$\someProof$}
        \noLine
        \UnaryInfC{$\ctx \judG \form$}
        \RL{\ruleForallI}
        \UnaryInfC{$\ctx \judG \forall . \var \form$}
        \RL{\ruleForallE}
        \UnaryInfC{$\ctx \judG \form \subst{\var}{\term}$}
        \DisplayProof
        \rewrite \quad
        \left(
        \AxiomC{$\someProof$}
        \noLine
        \UnaryInfC{$\ctx \judG \form$}
        \DisplayProof
        \right)\subst{\var}{\term}
    \]
    \proofSpacing
    \[
        \AxiomC{$\someProof_\form$}
        \noLine
        \UnaryInfC{$\ctx \judG \form \subst{\var}{\term}$}
        \RL{\ruleExistsI}
        \UnaryInfC{$\ctx \judG \exists \var . \form$}
        \AxiomC{$\someProof_\formTwo$}
        \noLine
        \UnaryInfC{$\ctx, \hypId: \form \judG \formTwo$}
        \BinaryInfC{$\ctx \judG \formTwo$}
        \DisplayProof
        \rewrite \quad
        \left(
        \left(
            \AxiomC{$\someProof_\formTwo$}
            \noLine
            \UnaryInfC{$\ctx, \hypId: \form \judG \formTwo$}
            \DisplayProof
        \right)\subst{\var}{\term}
        \right)\subst{\hypId}{\someProof_\form}
    \]
    
    \caption{Reglas de reducción}
    \label{fri:fig:reduction-rules}
\end{figure}

A partir de todas las reglas de reducción (\namedref{fri:fig:reduction-rules}), dado que son \textit{pasos} que acercan la demostración sucesivamente a su versión normalizada, podemos implementarlo de forma análoga a la conversión a DNF (\namedref{ppa:sec:dnf:algoritmo}) como la clausura reflexiva transitiva de la reducción en un paso: aplicarla 0 o más veces hasta que esté en forma normal. Al igual que DNF, también necesitaremos reglas de congruencia: si no hay una eliminación de una introducción para simplificar, se trata de reducir recursivamente las sub-demostraciones.

En una primera implementación las sub-demostraciones las reducíamos en un paso, de izquierda a derecha. Por ejemplo, si teníamos una introducción de una conjunción,

\proofTreeAndI

reducíamos de a un paso a la vez $\form \rewrite \form_1 \rewrite \form_2
\rewrite \dots \rewrite \form^{*}$ hasta llegar a $\form^{*}$ irreducible y
recién ahí aplicamos mismo para $\formTwo$, paso por paso. Esto resultó
excesivamente lento, dado que las demostraciones a reducir son muy grandes,
porque son generadas automáticamente. Además, si la sub-demostración que había
que reducir estaba muy anidada, había que recorrerla toda cada vez para efectuar
cada paso.

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form}$}
    \AxiomC{$\judg{\ctx}{\formTwo}$}
    \RL{\ruleAndI}
    \BinaryInfC{$\judg{\ctx}{\form \wedge \formTwo}$}
    \noLine
    \UnaryInfC{$\vdots$}
    \noLine
    \UnaryInfC{$\someProof$}
\end{prooftree}

Las sustituciones también eran más costosas, porque tenían que recorrer demostraciones de una profundidad mayor, y hay que recorrer el árbol entero para ver las hipótesis citadas y efectuar la sustitución en si.

Para solucionar este problema, implementamos una reducción en muchos pasos. En
la literatura se pueden encontrar muchas \textit{estrategias de reducción}
alternativas, que se clasifican en si reducen en un paso o muchos para cada
iteración de la clausura. Dentro de las de muchos, la que implementamos fue
\textbf{Gross-Knuth}, que reduce en muchos pasos todos los sub-términos posibles
al mismo tiempo. Aplicado a demostraciones, quiere decir que en un único paso de
reducción, reduciríamos $\form \fAnd \formTwo \rewrite \form^{*}
\fAnd \formTwo^{*}$. Esto hace que la convergencia sea mucho más rápida.

\duda{Probablemente falta rigurosidad en esta sección.}

\subsection{Limitaciones}
\label{fri:norm:sec:limitations}

Implementamos una reducción sencilla, que solamente reduce eliminaciones de introducciones de la misma regla. Pero hay otros patrones que dejamos afuera, 
que si ocurren, no nos permitirán llegar a una forma normal. Entonces no siempre podremos extraer un testigo. Por ejemplo, en \fullref{fri:norm:fig:non-norm}, se puede observar una demostración sencilla que usa \lstinline{cases}. Pero al certificarla, traducirla y reducirla, no queda en una forma normal. Se repite dos veces \ruleExistsI{}, cuando se podría mover hacia la raíz del árbol y evitar repetirlo en cada rama del \ruleOrE{}. Esto hace que al intentar extraer un testigo, el programa reporte una falla. Para soportar estos casos sería necesario sofisticar la reducción, agregando otro tipo de reglas, que quedó fuera del alcance del trabajo.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \caption{Programa de PPA}
        \lstinputlisting{listings/extract/or-fail.ppa}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[b]{1\textwidth}
        \caption{Demostración certificada, traducida y reducida (generada por \ppaTool{})}
        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judgI p(k) \fOr q(k)$}
            %
            \AxiomC{$\someProof_L$}
            \noLine
            \UnaryInfC{$\ctx, p(k) \judgI \exists y . r(y)$}
            %
            \AxiomC{$\someProof_R$}
            \noLine
            \UnaryInfC{$\ctx, q(k) \judgI \exists y . r(y)$}
            \RL{\ruleOrE}
            \TrinaryInfC{$\ctx \judgI \exists y . r(y)$}
        \end{prooftree}

        con $\someProof_L$ definido de la siguiente forma, y $\someProof_R$ simétrico.

        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx, p(k) \judgI p(k) \fImp r(k)$}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx, p(k) \judgI p(k)$}
            \BinaryInfC{$\ctx, p(k) \judgI r(k)$}
            \RL{\ruleExistsI}
            \LL{$\someProof_L =$}
            \UnaryInfC{$\ctx, p(k) \judgI \exists y . r(y)$}
        \end{prooftree}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[b]{1\textwidth}
        \caption{Demostración en forma normal (deseada)}
        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judgI p(k) \fOr q(k)$}
            %
            \AxiomC{$\someProof_L$}
            \noLine
            \UnaryInfC{$\ctx, p(k) \judgI r(y)$}
            %
            \AxiomC{$\someProof_R$}
            \noLine
            \UnaryInfC{$\ctx, q(k) \judgI r(k)$}
            \RL{\ruleOrE}
            \TrinaryInfC{$\ctx \judgI r(k)$}
            \RL{\ruleExistsI}
            \UnaryInfC{$\ctx \judgI \exists y . r(y)$}
        \end{prooftree}

        con $\someProof_L$ y $\someProof_R$ análogas al caso anterior, pero sin
        \ruleExistsI{}.
    \end{subfigure}
    \caption{Ejemplo de demostración no normalizada}
    \label{fri:norm:fig:non-norm}
\end{figure}

\section{Manteniendo el contexto}
\label{fri:sec:context}

Describimos todo el proceso de cómo a partir de una demostración en PPA, se certifica, se traduce mediante Friedman y se reduce para extraer testigos de un existencial. Pero falta exponer un detalle fundamental. Cuando estábamos probando la integración de todas las partes, nos dimos cuenta de un problema. \ppaTool{} implementa el resultado del \fullref{fri:cor:forall-inst}, que nos permite llevar las demostraciones a esta forma
\[
    \bm{\transDNeg{\ctx}} \judgI
    \exists \var .
    \anyForm(\var, \term_1, \dots, \term_n).
\]

Pero si tenemos por ejemplo el programa de la \fullref{fri:prog:exists},

\lstinputlisting{listings/extract/exists.ppa}

Al certificarlo y traducirlo, la demostración resultante es válida \textbf{con el contexto traducido}. Este está conformado por los axiomas, entonces la demostración traducida es de
\[
    \fNotR \fNotR p(v) \judgI \exists x . p(x)
\]
que al reducirlo, queda
\begin{prooftree}
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{\(
        \fNotR \fNotR p(v) \judgI \fNotR \fNotR p(v)
    \)}
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{\(
        \fNotR \fNotR p(v), p(v) \judgI p(v)
    \)}
    \RL{\ruleExistsI}
    \UnaryInfC{\(
        \fNotR \fNotR p(v), p(v) \judgI R = \exists x . p(x)
    \)}
    \RL{\ruleImpI}
    \UnaryInfC{\(
        \fNotR \fNotR p(v) \judgI \fNotR p(v)
    \)}
    \RL{\ruleImpE}
    \BinaryInfC{\(
        \fNotR \fNotR p(v) \judgI \exists x . p(x)
    \)}
\end{prooftree}

¡Nunca llega a la forma normal deseada! Conceptualmente, para que exista la forma normal debería poder comenzar con \ruleExistsI{} y demostrar de alguna forma $\fNotR \fNotR p(v) \judgI p(v)$, que no es posible. Otra forma más práctica de verlo es que con las reglas que definimos no se puede reducir, porque se elimina una implicación que se demuestra mediante \ruleAx{} de un axioma en vez de \ruleImpI{}, por lo que se traba.

Esto es análogo al problema que tendríamos si intentamos normalizar la demostración de un teorema que cita a otros, sin insertar las demostraciones de ellos. Cuando llega a la cita como axioma, se queda trabado.

\duda{Qué intuición agregar del problema? Algo de que el contenido computacional de los axiomas es limitado?}

La solución que implementamos fue \textbf{mantener los axiomas originales}, y demostrar la introducción de la traducción (\namedref{fri:lemma:trans-intro}, regla \ruleTransI{}): $p(v) \judgI \tdn{p(v)}$. Una vez generada la demostración de Friedman para la traducción se efectúa un paso más: por cada axioma, reemplazar cada lugar en donde se cita (que pretende encontrarlo traducido) por la demostración de la traducción \textit{a partir del axioma original}.

\begin{prooftree}
    \AxiomC{}
    \RL{\ruleTransI}
    \admissibleRuleLine
    \UnaryInfC{\(
        p(v) \judgI \fNotR \fNotR p(v)
    \)}
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{\(
        p(v) \judgI p(v)
    \)}
    \RL{\ruleExistsI}
    \UnaryInfC{\(
        p(v) \judgI R = \exists x . p(x)
    \)}
    \RL{\ruleImpI}
    \UnaryInfC{\(
        p(v) \judgI \fNotR p(v)
    \)}
    \RL{\ruleImpE}
    \BinaryInfC{\(
        p(v) \judgI \exists x . p(x)
    \)}
\end{prooftree}


De esa forma, como los axiomas se mantienen, existe la forma normal que buscamos y nuestra reducción llega a ella para este caso.

\begin{prooftree}
    \AxiomC{}
    \RL{\ruleAx}
    \UnaryInfC{\(
        p(v) \judgI p(v)
    \)}
    \RL{\ruleExistsI}
    \UnaryInfC{\(
        p(v) \judgI \exists x . p(x)
    \)}
\end{prooftree}

\begin{lemma}[Introducción de la traducción $\fNot\fNot$]
    \label{fri:lemma:trans-intro}
    Vale $\form \judgI \tdn{\form}$. Pero no para todas las fórmulas \cite{selinger-friedman}. Lo demostramos para las descritas por la siguiente gramática.
    \begin{align*}
        \form ::=\     & \fFalse \mid \fTrue \mid \pred(\term_1, \dots, \term_n) \mid \form \fAnd \form \\
        \formTwo ::=\  & \pred(\term_1, \dots, \term_n) \mid \fFalse \mid \fTrue                        \\
                       & \mid \formTwo \fAnd \formTwo \mid \formTwo \fOr \formTwo                       \\
                       & \mid \forall \var . \formTwo \mid \exists \var . \formTwo                      \\
                       & \mid \form \fImp \formTwo                                                      \\
                       & \mid \fNot \form
    \end{align*}

    Esto es suficientemente permisivo para los axiomas que se suelen definir. Veremos que $\formTwo$ son las fórmulas que cumplen $\formTwo \judgI \tdn{\formTwo}$ (este lema) y $\form$ las que cumplen $\fNotR \form \judgI \fNotR \tdn{\form}$ (\namedref{fri:lemma:notr-trans-intro}) 
\end{lemma}
\begin{proof}
    Se demuestra por inducción estructural en la fórmula (sin traducir).
    \begin{itemize}
        \item Los casos de predicados, $\fTrue, \fFalse, \fOr, \fAnd, \forall, \exists$ salen directo.
        \item $\fNot$ y $\fImp$ son las rebuscadas. Al ser contra variantes, no se pueden demostrar de forma directa porque no alcanza con la HI, sino que es necesario $\tdn{\form} \judgI \form$ que en general no vale. Pero sí es posible reducirlo a $\fNotR \form \judgI \fNotR \tdn{\form}$ (\namedref{fri:lemma:notr-trans-intro}, \ruleNotRTransI{}).
    \end{itemize}

    La negación es la más sencilla

    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\fNot \form, \form \judgI \fNot \form$}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\fNot \form, \form \judgI \form$}
        \RL{\ruleFalseE}
        \BinaryInfC{$\fNot \form, \form \judgI R$}
        \RL{\ruleImpI}
        \UnaryInfC{$\fNot \form \judgI \fNotR \form$}
        \RL{\ruleCutWith{\ruleNotRTransI}}
        \UnaryInfC{$\fNot \form \judgI \fNotR \tdn{\form}$}
    \end{prooftree}

    La implicación no tanto. Veamos la estrategia.

    \begin{itemize}
        \item Debemos probar $\form \fImp \formTwo \judgI \tdn{\form} \fImp \tdn{\formTwo}$.
        \item Lo vamos a reducir a demostrar los contrarecíprocos con \ruleCut{}
        \[
            \fNotR \formTwo \fImp \fNotR \form
            \judgI
            \fNotR \tdn{\formTwo} \fImp \fNotR \tdn{\form}
        \]
        Para ello necesitamos los siguientes lemas, sencillos de demostrar.
        \begin{itemize}
            \item $\form \fImp \formTwo \judgI \fNotR \formTwo \fImp \fNotR \form$
            \item $\fNotR \tdn{\formTwo} \fImp \fNotR \tdn{\form} \judgI \tdn{\form} \fImp \tdn{\formTwo}$ (requiere \ruleDnegRE{})
        \end{itemize}
        \item Reducimos a $\fNotR \form \judgI \fNotR \tdn{\form}$ para el antecedente y usamos la HI para el consecuente ($\formTwo \judgI \tdn{\formTwo}$) y concluimos.
        
        \begin{prooftree}
            \AxiomC{}
            \RL{\ruleAx{}}
            \UnaryInfC{\(
                \ctx_1
                \judgI \fNotR \formTwo \fImp \fNotR \form
            \)}
            \AxiomC{}
            \RL{\ruleAx}
            \UnaryInfC{\(
                \ctx_1, \formTwo \judgI \fNotR \tdn{\formTwo}
            \)}
            \AxiomC{(HI)}
            \noLine
            \UnaryInfC{\(
                \ctx_1, \formTwo \judgI \tdn{\formTwo}
            \)}
            \RL{\ruleImpE}
            \BinaryInfC{\(
                \ctx_1, \formTwo \judgI R
            \)}
            \RL{\ruleImpI}
            \UnaryInfC{\(
                \ctx_1 \judgI \fNotR \formTwo
            \)}
            \RL{\ruleImpE}
            \BinaryInfC{\(
                \ctx_1
                \judgI \fNotR \form
            \)}
            \RL{\ruleCutWith{\ruleNotRTransI}}
            \admissibleRuleLine
            \UnaryInfC{\(
                \ctx_1 = \fNotR \formTwo \fImp \fNotR \form, \fNotR \tdn{\formTwo}
                \judgI
                \fNotR \tdn{\form}
            \)}
            \RL{\ruleImpI}
            \UnaryInfC{\(
                \fNotR \formTwo \fImp \fNotR \form
                \judgI
                \fNotR \tdn{\formTwo} \fImp \fNotR \tdn{\form}
            \)}
        \end{prooftree}
    \end{itemize}
\end{proof}

\begin{corollary}[Completitud]
    Vimos que el \fullref{fri:lemma:trans-intro}, $\form \judgI \tdn{\form}$, se reduce al \fullref{fri:lemma:notr-trans-intro}, $\fNotR \form \judgI \fNotR \tdn{\form}$. En \cite{selinger-friedman} se exhibe un contra ejemplo para $\form \judgI \tdn{\form}$ (en una versión distinta pero equivalente de la traducción de Friedman): $\fNot \fNot \form$.
    
    Como el primero se reduce al segundo, si el primero no vale, entonces el
    segundo en general no puede valer. Y esto es consistente con nuestros
    resultados, dado que tampoco pudimos demostrar $\fNot \fNot \form$ pues no
    es generada por la gramática definida en el \namedref{fri:lemma:trans-intro}.
\end{corollary}

\section{Otros métodos de extracción}

A lo largo de este capítulo presentamos nuestra estrategia para extracción de testigos de demostraciones de lógica clásica, que tienen el desafío de no siempre ser constructivas por la existencia del principio de razonamiento clásico \ruleLEM{}. Pero hay más formas de hacerlo.
Vimos que las reglas de reducción en lógica intuicionista en realidad no son más que una semántica operacional del cálculo $\lambda$, por Curry-Howard. Muchas veces se usan isomorfismos como este, por ser más fácil pensar en semánticas operacionales que normalización de demostraciones. El problema con la lógica clásica es que no es sencillo dar esa interpretación computable, de una forma tal que permita hacer la extracción. Los métodos para hacerlo se dividen en dos categorías a grandes rasgos: directos e indirectos \cite{miquel-friedman}.

Los \textbf{indirectos} traducen las demostraciones clásicas de un subconjunto de fórmulas a otras lógicas que se porten mejor, como la intuicionista. Aprovechan el hecho de que es constructiva y tiene una interpretación computable bien conocida. Se puede efectuar con diferentes tipos de traducciones negativas, como la traducción de Friedman, que es lo que hicimos en este trabajo.

Por otro lado, también se puede hacer de forma \textbf{directa}, dando una interpretación computable de la lógica clásica. A esto se le llama \textit{realizabilidad clásica}, que consiste en dar una semántica operacional para cálculos $\lambda$ clásicos.