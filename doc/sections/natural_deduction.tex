Vamos a arrancar por las fundaciones: ¿Cómo se representa una demostración en la
computadora?

\begin{itemize}
    \item Ejemplo de demostración en lenguaje natural
    \item Necesitamos una forma estructural de representar demostraciones
    \item Proof calculus / proof system enmarcado en Proof theory. Cómo están
    compuestos en general
    \item Natural deduction
    \item Reglas de introducción y eliminación
    \item Formalización del ejemplo
    \item Ejemplo con cuantificadores
    \item Cut como meta-teorema (y meta teoremas en general)
    \item Implementación de data types principales
    \item Algoritmo de chequeo
    \item Algoritmos adicionales: alpha igualdad, variables libres, sust sin capturas
\end{itemize}

\section{Deducción natural}
Dos tipos de reglas

\begin{itemize}
    \item \textbf{Introducción}: Cómo demuestro?
    \item \textbf{Eliminación}: Cómo lo uso para demostrar?
\end{itemize}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\bot}$}
        \RL{\ruleE{$\bot$}}
        \UnaryInfC{$\judg{\ctx}{\form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleI{$\top$}}
        \UnaryInfC{$\judg{\ctx}{\top}$}
    \end{prooftree}
\end{multicols}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{}
        \RL{LEM}
        \UnaryInfC{$\judg{\ctx}{\form \vee \neg \form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{}
        \RL{Ax}
        \UnaryInfC{$\judg{\ctx, \hypId:\form}{\hypId:\form}$}
    \end{prooftree}
\end{multicols}

\vspace*{0.5cm}


\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form}$}
    \AxiomC{$\judg{\ctx}{\formTwo}$}
    \RL{\ruleI{$\wedge$}}
    \BinaryInfC{$\judg{\ctx}{\form \wedge \formTwo}$}
\end{prooftree}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form \wedge \formTwo}$}
        \RL{\ruleE{$\wedge_1$}}
        \UnaryInfC{$\judg{\ctx}{\form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form \wedge \formTwo}$}
        \RL{\ruleE{$\wedge_2$}}
        \UnaryInfC{$\judg{\ctx}{\formTwo}$}
    \end{prooftree}
\end{multicols}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form}$}
        \RL{\ruleI{$\vee_1$}}
        \UnaryInfC{$\judg{\ctx}{\form \vee \formTwo}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\formTwo}$}
        \RL{\ruleI{$\vee_2$}}
        \UnaryInfC{$\judg{\ctx}{\form \vee \formTwo}$}
    \end{prooftree}
\end{multicols}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form \vee \formTwo}$}
    \AxiomC{$\judg{\ctx, \form}{\formThree}$}
    \AxiomC{$\judg{\ctx, \formTwo}{\formThree}$}
    \RL{\ruleE{$\vee$}}
    \TrinaryInfC{$\judg{\ctx}{\formThree}$}
\end{prooftree}

\ruleE{$\vee$} nos deja inferir una conclusión a partir de una disyunción dando sub demostraciones que muestran como la conclusión se puede deducir asumiendo cualquiera de los elementos.

\begin{prooftree}
    \AxiomC{$\judg{\ctx, \form}{\formTwo}$}
    \RL{\ruleI{$\to$}}
    \UnaryInfC{$\judg{\ctx}{\form \to \formTwo}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form \to \formTwo}$}
    \AxiomC{$\judg{\ctx}{\form}$}
    \RL{\ruleE{$\to$} \scriptsize (modus ponens)}
    \BinaryInfC{$\judg{\ctx}{\formTwo}$}
\end{prooftree}

\vspace{0.5cm}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx, \form}{\bot}$}
        \RL{\ruleI{$\neg$}}
        \UnaryInfC{$\judg{\ctx}{\neg \form}$}
    \end{prooftree}
    
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\neg \form}$}
        \AxiomC{$\judg{\ctx}{\form}$}
        \RL{\ruleE{$\neg$}}
        \BinaryInfC{$\judg{\ctx}{\bot}$}
    \end{prooftree}
    
\end{multicols}

\todo{Validar las justificaciones coloquiales de acá}

Las reglas de $\forall$ y $\exists$ se pueden ver como extensiones a las de $\wedge$ y $\vee$.

Un $\forall$ se puede pensar como una conjunción con un elemento por cada uno dl dominio sobre el cual se cuantifica.

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form}$}
        \AxiomC{$x \notin fv(\ctx)$}
        \RL{\ruleI{$\forall$}}
        \BinaryInfC{$\judg{\ctx}{\forall \var.\form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\forall \var.\form}$}
        \RL{\ruleE{$\forall$}}
        \UnaryInfC{$\judg{\ctx}{\form \{\var := \term\}}$}
    \end{prooftree}
\end{multicols}

\begin{itemize}
    \item \ruleE{$\forall$}: Para usar un $\forall x.\form$ para demostrar (eliminar) instancio el $x$ en cualquier \textit{término} $t$, ya que es válido para todos.
    \item \ruleI{$\forall$}: Para demostrar (introducir) un $\forall x. \form$, quiero ver que sin importar el valor que tome $x$ yo puedo demostrar $\form$. Pero para eso en mi contexto $\Gamma$ no tengo que tenerlo ligado a nada, sino no lo estaría demostrando en general
\end{itemize}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form\{\var := \term\}}$}
    \RL{\ruleI{$\exists$}}
    \UnaryInfC{$\judg{\ctx}{\exists \var. \form}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\exists \var.\form}$}
    \AxiomC{$\judg{\ctx, \form}{\formTwo}$}
    \AxiomC{$x \notin fv(\ctx, \formTwo)$}
    \RL{\ruleE{$\exists$}}
    \TrinaryInfC{$\judg{\ctx}{\formTwo}$}
\end{prooftree}


\begin{itemize}
    \item \ruleI{$\exists$}: Para demostrar un $\exists$, alcanza con instanciar la variable en un término $t$ que sea válido.
    \item \ruleE{$\exists$}: Para usar un $\exists$ para demostrar, es parecido a \ruleE{$\vee$}. Como tenemos que ver que vale para cualquier $\var$, podemos concluir $\formTwo$ tomando como hipótesis $\form$ con $\var$ sin instanciar. 
\end{itemize}