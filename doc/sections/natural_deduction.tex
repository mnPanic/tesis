\begin{itemize}
    \item Ejemplo de demostración en lenguaje natural
    \item Necesitamos una forma estructural de representar demostraciones
    \item Proof calculus / proof system enmarcado en Proof theory. Cómo están
    compuestos en general
    \item Natural deduction
    \item Reglas de introducción y eliminación
    \item Formalización del ejemplo
    \item Ejemplo con cuantificadores
    \item Cut como meta-teorema (y meta teoremas en general)
    \item Implementación de data types principales
    \item Algoritmo de chequeo
    \item Algoritmos adicionales: alpha igualdad, variables libres, sust sin capturas
\end{itemize}

Vamos a arrancar por las fundaciones: Queremos armar un programa que permita
escribir teoremas y demostraciones. ¿Cómo se representa una demostración en la
computadora? En el área de estudio de \textit{proof theory}, en la cuál las
demostraciones son tratadas como objetos matemáticos formales, nos encontramos
con los \textit{proof calculi} o \textit{proof systems}, que son sistemas
lógicos formales que permiten demostrar sentencias. Pueden ser modelados como un
tipo abstracto de datos, así siendo representados en la computadora. Por
ejemplo, veamos la siguiente demostración en el dominio de exámenes en la
facultad, que vamos a ir iterando a lo largo de la tesis. Por ahora en su
versión proposicional, sin cuantificadores.

\begin{itemize}
    \item Si un alumno reprueba un final, entonces recursa (un criterio un poco duro)
    \item Si un alumno falta, entonces reprueba
    \item En base a eso, podemos demostrar que si un alumno falta a un final,
    entonces recursa.
\end{itemize}

\begin{ejemplo}\label{nd:ex:exam}
    Si ((reprueba entonces recursa) y (falta entonces reprueba)) y falta, entonces recursa.

    Demostración:
\begin{itemize}
    \item Asumo que falta. Quiero ver que recursa.
    \item Sabemos que si falta, entonces reprueba.
    \item Sabemos que si reprueba, entonces recursa.
    \item $\therefore$ recursa.
\end{itemize}
    \qed
\end{ejemplo}

¿Cómo podemos escribirla en un \textit{proof system}? En general, van a incluir
los siguientes componentes

\begin{itemize}
    \item \textbf{Lenguaje formal}: el conjunto $L$ de fórmulas admitidas por
    el sistema. En nuestro caso, lógica de primer órden.
    \item \textbf{Reglas de inferencia}: lista de reglas que se usan para probar
    teoremas de axiomas y otros teoremas. Por ejemplo, \textit{modus ponens} (si
    es cierto $\form \rightarrow \formTwo$ y $\form$, se puede concluir $\formTwo$) o
    \textit{modus tollens} (si es cierto $\form \rightarrow \formTwo$ y $\neg
    \formTwo$, se puede concluir $\neg\form$)
    \item \textbf{Axiomas}: fórmulas de $L$ que se asumen válidas. Todos los
    teoremas se derivan de axiomas. Por ejemplo, como estamos en lógica clásica,
    vale el axioma \textit{LEM} (Law of Excluded Middle): $\form \vee \neg \form$
\end{itemize}

\section{Deducción natural}

El sistema que usamos se conoce como \textbf{deducción natural}, introducido por
Gerhard Gentzen en \cite{gentzen-1935} \todo{Chequear cita}. Tiene dos tipos de
reglas de inferencia para cada operador ($\wedge$, $\vee$, $\exists$, $\dots$)

\begin{itemize}
    \item \textbf{Introducción}: ¿Cómo demuestro este operador?
    \item \textbf{Eliminación}: ¿Cómo uso este operador para demostrar otra fórmula?
\end{itemize}

\newcommand{\reprueba}{X}
\newcommand{\recursa}{R}
\newcommand{\falta}{F}

\begin{ejemplo}
    Demostración de \fullref{nd:ex:exam}. Notamos
    \begin{itemize}
        \item $\reprueba \equiv$ reprueba
        \item $\recursa \equiv$ recursa
        \item $\falta \equiv$ falta
    \end{itemize}

    Queremos probar entonces 
    \(
        \Big(
            (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba)
        \Big)
        \fImp
        (\falta \fImp \recursa)
    \)

    \todo{Validar poner la hyp arriba de los \ruleAx}
    \begin{figure}[H]
        \begin{prooftree}
            \AxiomC{$\hypId_1$}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judG (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba)$}
            \RL{\ruleAndEOne}
            \UnaryInfC{$\ctx \judG \reprueba \fImp \recursa$}
    
            \AxiomC{$\hypId_1$}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judG (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba)$}
            \RL{\ruleAndETwo}
            \UnaryInfC{$\ctx \judG \falta \fImp \reprueba$}
            \AxiomC{$\hypId_2$}
            \RL{\ruleAx}
            \UnaryInfC{$\ctx \judG \falta$}
            \RL{\ruleImpE}
            \BinaryInfC{$\ctx \judG \reprueba$}
            \RL{\ruleImpE}
            \BinaryInfC{\(
                \ctx =
                \hypId_1: (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba),\
                \hypId_2: \falta
                \judG
                \recursa
            \)}
            \RL{\ruleImpI}
            \UnaryInfC{\(
                \hypId_1: (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba)
                \judG
                \falta \fImp \recursa 
            \)}
            \RL{\ruleImpI}
            \UnaryInfC{\(
                \judG
                \Big(
                    (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba)
                \Big)
                \fImp
                (\falta \fImp \recursa)
            \)}
        \end{prooftree}
    
        \caption{Demostración de \(
        \big(
            (\reprueba \fImp \recursa) \wedge (\falta \fImp \reprueba)
        \big)
        \fImp
        (\falta \fImp \recursa)
    \) en deducción natural}
        \label{nd:fig:proof-exam-nd}
    \end{figure}

    Paso por paso,

    \begin{itemize}
        \item \ruleImpI: \textit{introducimos} la implicación. Para demostrarla,
        asumimos el antecedente y en base a eso demostramos el consecuente. Es
        decir asumimos $(\reprueba \fImp \recursa) \wedge (\falta \fImp
        \reprueba)$, y en base a eso queremos deducir $\falta \fImp \recursa$.
        Las \textit{hipótesis} están etiquetadas, en este caso $\hypId_1$.
        \item \ruleImpI: Asumimos $\falta$, nos queda probar $\recursa$.
        Renombramos el \textit{contexto} de hipótesis como $\ctx$.
        \item La estrategia para probar $\recursa$ es usando la siguiente cadena
        de implicaciones: $\falta \fImp \reprueba \fImp \recursa$, y sabemos que
        vale $\falta$. Como tenemos que probar $\recursa$, arrancamos de atrás para
        adelante.
        \item \ruleImpE: \textit{eliminamos} una implicación, la usamos para
        deducir su conclusión demostrando el antecedente. Esta regla de
        inferencia tiene dos partes, probar la implicación ($\reprueba \fImp
        \recursa$), y probar el antecedente ($\reprueba$).
        \begin{itemize}
            \item Para probar la implicación, tenemos que usar la hipótesis
            $\hypId_1$, \textit{eliminando} la conjunción y especificando cuál
            de las dos cláusulas estamos usando.
            \item Para probar el antecedente $\reprueba$, es un proceso análogo
            pero usando la otra implicación y el hecho de que vale $\falta$ por hipótesis.
        \end{itemize}
        \item Las raíces del árbol, los casos base, suelen ser aplicaciones de
        la regla de inferencia \ruleAx, que permite deducir fórmulas citando
        hipótesis del contexto.
    \end{itemize}
\end{ejemplo}

\subsection{Reglas de inferencia}

A continuación introducimos todas las reglas de inferencia para deducción
natural para lógica de primer órden.

\todo{Incluir explicación de cada una?}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\bot}$}
        \RL{\ruleFalseE}
        \UnaryInfC{$\judg{\ctx}{\form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleTrueI}
        \UnaryInfC{$\judg{\ctx}{\top}$}
    \end{prooftree}
\end{multicols}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleLEM}
        \UnaryInfC{$\judg{\ctx}{\form \vee \neg \form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{}
        \RL{\ruleAx}
        \UnaryInfC{$\judg{\ctx, \hypId:\form}{\hypId:\form}$}
    \end{prooftree}
\end{multicols}

\vspace*{0.5cm}


\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form}$}
    \AxiomC{$\judg{\ctx}{\formTwo}$}
    \RL{\ruleAndI}
    \BinaryInfC{$\judg{\ctx}{\form \wedge \formTwo}$}
\end{prooftree}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form \wedge \formTwo}$}
        \RL{\ruleAndEOne}
        \UnaryInfC{$\judg{\ctx}{\form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form \wedge \formTwo}$}
        \RL{\ruleAndETwo}
        \UnaryInfC{$\judg{\ctx}{\formTwo}$}
    \end{prooftree}
\end{multicols}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form}$}
        \RL{\ruleOrIOne}
        \UnaryInfC{$\judg{\ctx}{\form \vee \formTwo}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\formTwo}$}
        \RL{\ruleOrITwo}
        \UnaryInfC{$\judg{\ctx}{\form \vee \formTwo}$}
    \end{prooftree}
\end{multicols}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form \vee \formTwo}$}
    \AxiomC{$\judg{\ctx, \form}{\formThree}$}
    \AxiomC{$\judg{\ctx, \formTwo}{\formThree}$}
    \RL{\ruleOrE}
    \TrinaryInfC{$\judg{\ctx}{\formThree}$}
\end{prooftree}

\ruleOrE nos deja inferir una conclusión a partir de una disyunción dando sub demostraciones que muestran como la conclusión se puede deducir asumiendo cualquiera de los elementos.

\begin{prooftree}
    \AxiomC{$\judg{\ctx, \form}{\formTwo}$}
    \RL{\ruleImpI}
    \UnaryInfC{$\judg{\ctx}{\form \to \formTwo}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form \to \formTwo}$}
    \AxiomC{$\judg{\ctx}{\form}$}
    \RL{\ruleImpE \scriptsize (modus ponens)}
    \BinaryInfC{$\judg{\ctx}{\formTwo}$}
\end{prooftree}

\vspace{0.5cm}

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx, \form}{\bot}$}
        \RL{\ruleNotI}
        \UnaryInfC{$\judg{\ctx}{\neg \form}$}
    \end{prooftree}
    
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\neg \form}$}
        \AxiomC{$\judg{\ctx}{\form}$}
        \RL{\ruleNotE}
        \BinaryInfC{$\judg{\ctx}{\bot}$}
    \end{prooftree}
    
\end{multicols}

\todo{Validar las justificaciones coloquiales de acá}

Las reglas de $\forall$ y $\exists$ se pueden ver como extensiones a las de $\wedge$ y $\vee$.

Un $\forall$ se puede pensar como una conjunción con un elemento por cada uno dl dominio sobre el cual se cuantifica.

\begin{multicols}{2}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\form}$}
        \AxiomC{$x \notin fv(\ctx)$}
        \RL{\ruleForallI}
        \BinaryInfC{$\judg{\ctx}{\forall \var.\form}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\judg{\ctx}{\forall \var.\form}$}
        \RL{\ruleForallE}
        \UnaryInfC{$\judg{\ctx}{\form \{\var := \term\}}$}
    \end{prooftree}
\end{multicols}

\begin{itemize}
    \item \ruleForallE: Para usar un $\forall x.\form$ para demostrar (eliminar) instancio el $x$ en cualquier \textit{término} $t$, ya que es válido para todos.
    \item \ruleForallI: Para demostrar (introducir) un $\forall x. \form$, quiero ver que sin importar el valor que tome $x$ yo puedo demostrar $\form$. Pero para eso en mi contexto $\Gamma$ no tengo que tenerlo ligado a nada, sino no lo estaría demostrando en general
\end{itemize}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\form\{\var := \term\}}$}
    \RL{\ruleExistsI}
    \UnaryInfC{$\judg{\ctx}{\exists \var. \form}$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\judg{\ctx}{\exists \var.\form}$}
    \AxiomC{$\judg{\ctx, \form}{\formTwo}$}
    \AxiomC{$x \notin fv(\ctx, \formTwo)$}
    \RL{\ruleExistsE}
    \TrinaryInfC{$\judg{\ctx}{\formTwo}$}
\end{prooftree}


\begin{itemize}
    \item \ruleExistsI: Para demostrar un $\exists$, alcanza con instanciar la variable en un término $t$ que sea válido.
    \item \ruleExistsE: Para usar un $\exists$ para demostrar, es parecido a \ruleE{$\vee$}. Como tenemos que ver que vale para cualquier $\var$, podemos concluir $\formTwo$ tomando como hipótesis $\form$ con $\var$ sin instanciar. 
\end{itemize}

\todo{Ejemplo con cuantificadores}

En síntesis,


\begin{figure}[H]
    \todo{Copiar y pegar todo cuando esté terminado}
    \caption{Reglas de inferencia para deducción natural de lógica de primer órden}
    \label{nd:inference-rules}
\end{figure}

\subsection{Meta-teoremas}

Antes mencionamos \textit{modus tollens} como regla de inferencia. Pero como nos
va a interesar tener un sistema lógico minimal, para simplificar el
\texttt{Checker} y todo el resto de los módulos que interactúen con él, lo
podemos demostrar como \textbf{meta-teorema}.

\todo{Demo modus tollens}

\todo{Cut como meta teorema}

\section{Implementación}

Data types principales

\begin{figure}[H]
\begin{minted}{haskell}
type VarId = String
type FunId = String
type PredId = String
type HypId = String

data Term
    = TVar VarId
    | TMetavar Metavar
    | TFun FunId [Term]

data Form
    = FPred PredId [Term]
    | FAnd Form Form
    | FOr Form Form
    | FImp Form Form
    | FNot Form
    | FTrue
    | FFalse
    | FForall VarId Form
    | FExists VarId Form
\end{minted}
    \caption{Extracto de modelado de deducción natural. Detalles de
    implementación irrelevantes fueron omitidos. Ver \texttt{src/ND.hs}}
\end{figure}

\todo{Mejorar formatting, 2 columnas?}
\begin{minted}{haskell}
data Proof =
    | PAx HypId
    | PAndI
        { proofLeft :: Proof
        , proofRight :: Proof
        }
    | PAndE1
        { right :: Form
        , proofAnd :: Proof
        }
    | PAndE2
        { left :: Form
        , proofAnd :: Proof
        }
    | POrI1
        { proofLeft :: Proof
        }
    | POrI2
        { proofRight :: Proof
        }
    | POrE
        { left :: Form
        , right :: Form
        , proofOr :: Proof
        , hypLeft :: HypId
        , proofAssumingLeft :: Proof
        , hypRight :: HypId
        , proofAssumingRight :: Proof
        }
    | PImpI
        { hypAntecedent :: HypId
        , proofConsequent :: Proof
        }
    | PImpE
        { antecedent :: Form
        , proofImp :: Proof
        , proofAntecedent :: Proof
        }
    | PNotI
        { hyp :: HypId
        , proofBot :: Proof
        }
    | PNotE
        { form :: Form
        , proofNotForm :: Proof
        , proofForm :: Proof
        }
    | PTrueI
    | PFalseE
        { proofBot :: Proof
        }
    | PLEM
    | PForallI
        { newVar :: VarId
        , proofForm :: Proof
        }
    | PForallE
        { var :: VarId
        , form :: Form
        , proofForall :: Proof
        , termReplace :: Term
        }
    | PExistsI
        { inst :: Term
        , proofFormWithInst :: Proof
        }
    | PExistsE
        { var :: VarId
        , form :: Form
        , proofExists :: Proof
        , hyp :: HypId
        , proofAssuming :: Proof
        }
\end{minted}

Las meta-variables se usan para unificación, que es parte del solver de PPA. Ver
más en \fullref{ppa:sec:unification}

El modelado de las reglas de inferencia omite varios detalles que están
implícitos y serán inferidos por el algoritmo de chequeo. De esa forma las
demostraciones son más fáciles de escribir y generar.

\subsection{Chequeo}

\begin{minted}{haskell}
-- Contexto / Environment de hipótesis
data Env
    = EEmpty
    | EExtend HypId Form Env
    deriving (Eq)
\end{minted}

\subsection{Sustitución sin capturas}

\duda{Escribir solamente la definición formal? + la implementación? Solo implementación?}

\subsection{Alpha igualdad}

\subsection{Variables libres}
